package objs

import (
	"io/ioutil"
	"log"
	"os"
	"strconv"
	"testing"

	"github.com/MadBase/MadNet/application/objs"
	"github.com/MadBase/MadNet/application/objs/uint256"
	"github.com/MadBase/MadNet/application/utxohandler"
	"github.com/MadBase/MadNet/constants"
	"github.com/MadBase/MadNet/crypto"
	"github.com/MadBase/MadNet/utils"
	"github.com/dgraph-io/badger/v2"
)

func generateChainRicLeo(length int) ([]*BClaims, [][][]byte, error) {
	chain := []*BClaims{}
	txHashes := [][][]byte{}
	// todo: replace me with the actual utxo/txhash smt generation
	txhash := crypto.Hasher([]byte(strconv.Itoa(1)))
	log.Printf("txhash: %x\n", txhash)
	txHshLst := [][]byte{txhash}
	txRoot, err := MakeTxRoot(txHshLst)
	log.Printf("txRoot (0): %x\n", txRoot)
	if err != nil {
		return nil, nil, err
	}
	txHashes = append(txHashes, txHshLst)
	bclaims := &BClaims{
		ChainID:    1,
		Height:     1,
		TxCount:    1,
		PrevBlock:  crypto.Hasher([]byte("foo")),
		TxRoot:     txRoot,
		StateRoot:  crypto.Hasher([]byte("")),
		HeaderRoot: crypto.Hasher([]byte("")),
	}
	chain = append(chain, bclaims)
	for i := 1; i < length; i++ {
		bhsh, err := chain[i-1].BlockHash()
		if err != nil {
			return nil, nil, err
		}
		txhash := crypto.Hasher([]byte(strconv.Itoa(i)))
		txHshLst := [][]byte{txhash}
		txRoot, err := MakeTxRoot(txHshLst)
		log.Printf("txRoot (%d): %x\n", i, txRoot)
		if err != nil {
			return nil, nil, err
		}
		txHashes = append(txHashes, txHshLst)
		bclaims := &BClaims{
			ChainID:    1,
			Height:     uint32(len(chain) + 1),
			TxCount:    1,
			PrevBlock:  bhsh,
			TxRoot:     txRoot,
			StateRoot:  chain[i-1].StateRoot,
			HeaderRoot: chain[i-1].HeaderRoot,
		}
		chain = append(chain, bclaims)
	}
	return chain, txHashes, nil
}

func makeDeposit(t *testing.T, s objs.Signer, chainID uint32, i int, value *uint256.Uint256) *objs.ValueStore {
	pubkey, err := s.Pubkey()
	if err != nil {
		t.Fatal(err)
	}
	vs := &objs.ValueStore{
		VSPreImage: &objs.VSPreImage{
			TXOutIdx: constants.MaxUint32,
			Value:    value,
			ChainID:  chainID,
			Owner:    &objs.ValueStoreOwner{SVA: objs.ValueStoreSVA, CurveSpec: constants.CurveSecp256k1, Account: crypto.GetAccount(pubkey)},
		},
		TxHash: utils.ForceSliceToLength([]byte(strconv.Itoa(i)), constants.HashLen),
	}
	return vs
}

func makeTxs(t *testing.T, s objs.Signer, v *objs.ValueStore) *objs.Tx {
	txIn, err := v.MakeTxIn()
	if err != nil {
		t.Fatal(err)
	}
	value, err := v.Value()
	if err != nil {
		t.Fatal(err)
	}
	chainID, err := txIn.ChainID()
	if err != nil {
		t.Fatal(err)
	}
	pubkey, err := s.Pubkey()
	if err != nil {
		t.Fatal(err)
	}
	tx := &objs.Tx{}
	tx.Vin = []*objs.TXIn{txIn}
	// the new utxo that will be generated by this transaction
	newValueStore := &objs.ValueStore{
		VSPreImage: &objs.VSPreImage{
			ChainID:  chainID,
			Value:    value,
			Owner:    &objs.ValueStoreOwner{SVA: objs.ValueStoreSVA, CurveSpec: constants.CurveSecp256k1, Account: crypto.GetAccount(pubkey)},
			TXOutIdx: 0,
		},
		TxHash: make([]byte, 32),
	}
	newUTXO := &objs.TXOut{}
	err = newUTXO.NewValueStore(newValueStore)
	if err != nil {
		t.Fatal(err)
	}
	tx.Vout = append(tx.Vout, newUTXO)
	err = tx.SetTxHash() // <- compute the root from the TxHash smt
	if err != nil {
		t.Fatal(err)
	}
	err = v.Sign(tx.Vin[0], s)
	if err != nil {
		t.Fatal(err)
	}
	return tx
}

func makeTransfer(t *testing.T, sender objs.Signer, receiver objs.Signer, transferAmount uint64, v *objs.ValueStore) *objs.Tx {
	txIn, err := v.MakeTxIn()
	if err != nil {
		t.Fatal(err)
	}
	value, err := v.Value()
	vuint64, err := value.ToUint64()
	returnedAmount := vuint64 - transferAmount
	value = &uint256.Uint256{}
	_, _ = value.FromUint64(returnedAmount)
	value2 := &uint256.Uint256{}
	_, _ = value2.FromUint64(transferAmount)

	if err != nil {
		t.Fatal(err)
	}
	chainID, err := txIn.ChainID()
	if err != nil {
		t.Fatal(err)
	}
	receiverPubkey, err := receiver.Pubkey()
	if err != nil {
		t.Fatal(err)
	}

	senderPubkey, err := sender.Pubkey()
	if err != nil {
		t.Fatal(err)
	}

	tx := &objs.Tx{}
	tx.Vin = []*objs.TXIn{txIn}
	newValueStoreSender := &objs.ValueStore{
		VSPreImage: &objs.VSPreImage{
			ChainID:  chainID,
			Value:    value,
			Owner:    &objs.ValueStoreOwner{SVA: objs.ValueStoreSVA, CurveSpec: constants.CurveSecp256k1, Account: crypto.GetAccount(senderPubkey)},
			TXOutIdx: 0,
		},
		TxHash: make([]byte, 32),
	}

	// the new utxo that will be generated by this transaction
	newValueStoreReceiver := &objs.ValueStore{
		VSPreImage: &objs.VSPreImage{
			ChainID:  chainID,
			Value:    value2,
			Owner:    &objs.ValueStoreOwner{SVA: objs.ValueStoreSVA, CurveSpec: constants.CurveSecp256k1, Account: crypto.GetAccount(receiverPubkey)},
			TXOutIdx: 1,
		},
		TxHash: make([]byte, 32),
	}
	newUTXOSender := &objs.TXOut{}
	err = newUTXOSender.NewValueStore(newValueStoreSender)
	if err != nil {
		t.Fatal(err)
	}

	newUTXOReceiver := &objs.TXOut{}
	err = newUTXOReceiver.NewValueStore(newValueStoreReceiver)
	if err != nil {
		t.Fatal(err)
	}
	tx.Vout = append(tx.Vout, newUTXOSender, newUTXOReceiver)
	err = tx.SetTxHash() // <- compute the root from the TxHash smt
	if err != nil {
		t.Fatal(err)
	}
	err = v.Sign(tx.Vin[0], sender)
	if err != nil {
		t.Fatal(err)
	}
	return tx
}

func TestRicLeo(t *testing.T) {
	// Database setup
	log.Println("TestRicLeo starting")
	dir, err := ioutil.TempDir("", "badger-test")
	if err != nil {
		t.Fatal(err)
	}
	defer func() {
		if err := os.RemoveAll(dir); err != nil {
			t.Fatal(err)
		}
	}()
	opts := badger.DefaultOptions(dir)
	db, err := badger.Open(opts)
	if err != nil {
		t.Fatal(err)
	}
	defer db.Close()

	//////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////
	signer := &crypto.Secp256k1Signer{}
	err = signer.SetPrivk(crypto.Hasher([]byte("secret")))

	if err != nil {
		t.Fatal(err)
	}

	signer2 := &crypto.Secp256k1Signer{}
	err = signer2.SetPrivk(crypto.Hasher([]byte("secret2")))

	if err != nil {
		t.Fatal(err)
	}

	hndlr := utxohandler.NewUTXOHandler(db)
	err = hndlr.Init(1)
	if err != nil {
		t.Fatal(err)
	}

	// Creating First UTXO
	// signer 1
	value := &uint256.Uint256{}
	_, _ = value.FromUint64(10)
	d := makeDeposit(t, signer, 1, 1, value) // created pre-image object
	utxoDep := &objs.TXOut{}
	err = utxoDep.NewValueStore(d) // <- create a txout to be used on Vout (a.k.a UTXO) from pre-image object
	if err != nil {
		t.Fatal(err)
	}
	tx := makeTxs(t, signer, d)
	txHash, err := tx.TxHash()
	if err != nil {
		t.Fatal(err)
	}
	log.Printf("Tx hash: %x", txHash)

	// Create the transaction with that first Utxo (coinbase generation)
	// Create the block
	err = db.Update(func(txn *badger.Txn) error {
		_, err := hndlr.IsValid(txn, []*objs.Tx{tx}, 1, objs.Vout{utxoDep})
		if err != nil {
			t.Fatal(err)
		}
		return nil
	})
	if err != nil {
		t.Fatal(err)
	}

	var stateRoot []byte
	err = db.Update(func(txn *badger.Txn) error {
		stateRoot, err = hndlr.ApplyState(txn, []*objs.Tx{tx}, 2)
		if err != nil {
			t.Fatal(err) //     ricleo_test.go:216: the object is invalid:not initialized
		}

		log.Printf("stateRoot: %x\n", stateRoot)
		return nil
	})
	if err != nil {
		t.Fatal(err)
	}

	//var stateTrie *trie.SMT
	err = db.Update(func(txn *badger.Txn) error {
		stateTrie, err := hndlr.GetTrie().GetCurrentTrie(txn)
		if err != nil {
			t.Fatal(err) //     ricleo_test.go:216: the object is invalid:not initialized
		}
		utxoIDs, err := tx.GeneratedUTXOID()
		log.Printf("Trie height: %d\n", stateTrie.Height())
		auditPath, keyIncluded, key, value, err := stateTrie.MerkleProof(txn, utxoIDs[0]) // *badger.Txn, key []byte
		if err != nil {
			log.Fatal("error getting merkle proof", err)
		}
		log.Println("==============Proof of inclusion============")
		log.Printf("auditPath: %x\n", auditPath)
		log.Print("Included:", keyIncluded)
		log.Printf("key: %x\n", key)
		log.Printf("value: %x\n", value)
		return nil
	})
	if err != nil {
		t.Fatal(err)
	}

	// generating block 1
	chain := []*BClaims{}
	txHashes := [][][]byte{}
	txHshLst := [][]byte{txHash}
	txRoot, err := MakeTxRoot(txHshLst) // generating the smt root
	log.Printf("txRoot (0): %x\n", txRoot)
	if err != nil {
		log.Fatal("error making txroot")
	}
	txHashes = append(txHashes, txHshLst)
	bclaims := &BClaims{
		ChainID:    1,
		Height:     1,
		TxCount:    1,
		PrevBlock:  crypto.Hasher([]byte("foo")),
		TxRoot:     txRoot,
		StateRoot:  stateRoot,
		HeaderRoot: crypto.Hasher([]byte("")), //todo: how to generate the block smt
	}
	chain = append(chain, bclaims)

	log.Printf("Block: {\n\tChainID: %d\n\tHeight: %d\n\tTxCount: %d\n\tPrevBlock: %x\n\tTxRoot: %x\n\tStateRoot: %x\n\tHeaderRoot: %x\n}\n", bclaims.ChainID, bclaims.Height, bclaims.TxCount, bclaims.PrevBlock, bclaims.TxRoot, bclaims.StateRoot, bclaims.HeaderRoot)

	////////// Block 2 /////////////
	// this is consuming utxo generated on block 1
	//tx := makeTxs(t, signer, d) // <- creating a txin that consumes the UTXO created on block 1

	// signer 2
	//d2 := makeDeposit(t, signer2, 1, 1, uint256.Two())
	//utxoDep2 := &objs.TXOut{}
	// err = utxoDep.NewValueStore(d2)
	// if err != nil {,
	// 	t.Fatal(err)
	// }
	tx2 := makeTransfer(t, signer, signer2, 2, d)
	txHash2, err := tx2.TxHash()
	if err != nil {
		t.Fatal(err)
	}
	log.Printf("Tx hash: %x", txHash2)
	// err = db.Update(func(txn *badger.Txn) error {
	// 	_, err := hndlr.IsValid(txn, []*objs.Tx{tx2}, 1, objs.Vout{utxoDep2})
	// 	if err != nil {
	// 		t.Fatal(err)
	// 	}
	// 	return nil
	// })
	// if err != nil {
	// 	t.Fatal(err)
	// }
	err = db.Update(func(txn *badger.Txn) error {
		stateRoot, err = hndlr.ApplyState(txn, []*objs.Tx{tx2}, 2)
		if err != nil {
			t.Fatal(err) //     ricleo_test.go:216: the object is invalid:not initialized
		}

		log.Printf("stateRoot2: %x\n", stateRoot)
		return nil
	})
	if err != nil {
		t.Fatal(err)
	}

	// generating block2
	bhsh, err := chain[len(chain)-1].BlockHash()
	if err != nil {
		t.Fatal(err)
	}
	txHshLst = [][]byte{txHash2}
	txRoot, err = MakeTxRoot(txHshLst)
	log.Printf("txRoot (1): %x\n", txRoot)
	if err != nil {
		t.Fatal(err)
	}
	txHashes = append(txHashes, txHshLst)
	bclaims = &BClaims{
		ChainID:    1,
		Height:     uint32(len(chain) + 1),
		TxCount:    1,
		PrevBlock:  bhsh,
		TxRoot:     txRoot,
		StateRoot:  stateRoot,
		HeaderRoot: chain[len(chain)-1].HeaderRoot,
	}
	chain = append(chain, bclaims)
	log.Printf("Block: {\n\tChainID: %d\n\tHeight: %d\n\tTxCount: %d\n\tPrevBlock: %x\n\tTxRoot: %x\n\tStateRoot: %x\n\tHeaderRoot: %x\n}\n", bclaims.ChainID, bclaims.Height, bclaims.TxCount, bclaims.PrevBlock, bclaims.TxRoot, bclaims.StateRoot, bclaims.HeaderRoot)

	utxoIDs, err := tx.GeneratedUTXOID()
	if err != nil {
		t.Fatal(err)
	}
	err = db.Update(func(txn *badger.Txn) error {
		_, missing, err := hndlr.Get(txn, utxoIDs)
		if err != nil {
			t.Fatal(err)
		}
		if len(missing) != 0 {
			t.Fatal("missing utxoID")
		}
		_, missing, err = hndlr.Get(txn, [][]byte{crypto.Hasher([]byte("nil"))})
		if err != nil {
			t.Fatal(err)
		}
		if len(missing) != 1 {
			t.Fatal("not missing utxoID")
		}
		return nil
	})
	if err != nil {
		t.Fatal(err)
	}
}
