package utxohandler

import (
	"bytes"
	"encoding/hex"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"math/big"
	"os"
	"testing"

	"github.com/MadBase/MadNet/application/objs"
	"github.com/MadBase/MadNet/application/objs/uint256"
	trie "github.com/MadBase/MadNet/badgerTrie"
	"github.com/MadBase/MadNet/consensus/db"
	cobjs "github.com/MadBase/MadNet/consensus/objs"
	"github.com/MadBase/MadNet/constants"
	"github.com/MadBase/MadNet/crypto"
	"github.com/MadBase/MadNet/errorz"
	"github.com/MadBase/MadNet/utils"
	"github.com/dgraph-io/badger/v2"
)

// MakePersistentTxRoot creates a txRootHsh from a list of transaction hashes
func MakePersistentTxRoot(txn *badger.Txn, txHashes [][]byte) (*trie.SMT, []byte, error) {
	if len(txHashes) == 0 {
		return nil, crypto.Hasher([]byte{}), nil
	}
	values := [][]byte{}
	for i := 0; i < len(txHashes); i++ {
		txHash := txHashes[i]
		values = append(values, crypto.Hasher(txHash))
	}
	// new in persistent smt
	smt := trie.NewSMT(nil, trie.Hasher, func() []byte { return []byte("mtr") })
	// smt update
	txHashesSorted, valuesSorted, err := utils.SortKVs(txHashes, values)
	if err != nil {
		return nil, nil, err
	}
	rootHash, err := smt.Update(txn, txHashesSorted, valuesSorted)
	if err != nil {
		return nil, nil, err
	}
	return smt, rootHash, nil
}

// TxHash calculates the TxHash of the transaction
func PersistentTxHash(txn *badger.Txn, b *objs.Tx) (*trie.SMT, []byte, error) {
	if b == nil {
		return nil, nil, errorz.ErrInvalid{}.New("tx not initialized in txHash")
	}
	if err := b.Vout.SetTxOutIdx(); err != nil {
		return nil, nil, err
	}
	keys := [][]byte{}
	values := [][]byte{}
	for _, txIn := range b.Vin {
		id, err := txIn.UTXOID()
		if err != nil {
			return nil, nil, err
		}
		keys = append(keys, id)
		hsh, err := txIn.PreHash()
		if err != nil {
			return nil, nil, err
		}
		values = append(values, hsh)
	}
	for idx, txOut := range b.Vout {
		hsh, err := txOut.PreHash()
		if err != nil {
			return nil, nil, err
		}
		id := objs.MakeUTXOID(utils.CopySlice(hsh), uint32(idx))
		keys = append(keys, id)
		values = append(values, hsh)
	}
	for i, _ := range keys {
		log.Printf("TxHash Key: %x\n", keys[i])
		log.Printf("TxHash Value: %x\n", values[i])
	}
	// new in persistent smt
	smt := trie.NewSMT(nil, trie.Hasher, func() []byte { return []byte("mtt") })
	// smt update
	keysSorted, valuesSorted, err := utils.SortKVs(keys, values)
	if err != nil {
		return nil, nil, err
	}
	if len(keysSorted) == 0 && len(valuesSorted) == 0 {
		rootHash := crypto.Hasher([][]byte{}...)
		return smt, utils.CopySlice(rootHash), nil
	}
	rootHash, err := smt.Update(txn, keysSorted, valuesSorted)
	if err != nil {
		return nil, nil, err
	}
	return smt, utils.CopySlice(rootHash), nil
}

func makeTransfer(t *testing.T, sender objs.Signer, receiver objs.Signer, transferAmount uint64, v *objs.TXOut) *objs.Tx {
	txIn, err := v.MakeTxIn()
	if err != nil {
		t.Fatal(err)
	}
	txInHash, err := txIn.PreHash()
	if err != nil {
		t.Fatal(err)
	}
	log.Printf("TXIn PreHash: %x\n", txInHash)
	value, err := v.Value()
	vuint64, err := value.ToUint64()
	returnedAmount := vuint64 - transferAmount
	value = &uint256.Uint256{}
	_, _ = value.FromUint64(returnedAmount)
	value2 := &uint256.Uint256{}
	_, _ = value2.FromUint64(transferAmount)

	if err != nil {
		t.Fatal(err)
	}
	chainID, err := txIn.ChainID()
	if err != nil {
		t.Fatal(err)
	}
	receiverPubkey, err := receiver.Pubkey()
	if err != nil {
		t.Fatal(err)
	}

	senderPubkey, err := sender.Pubkey()
	if err != nil {
		t.Fatal(err)
	}

	tx := &objs.Tx{}
	tx.Vin = []*objs.TXIn{txIn}
	newValueStoreSender := &objs.ValueStore{
		VSPreImage: &objs.VSPreImage{
			ChainID:  chainID,
			Value:    value,
			Owner:    &objs.ValueStoreOwner{SVA: objs.ValueStoreSVA, CurveSpec: constants.CurveSecp256k1, Account: crypto.GetAccount(senderPubkey)},
			TXOutIdx: 0,
		},
		TxHash: make([]byte, 32),
	}

	// the new utxo that will be generated by this transaction
	newValueStoreReceiver := &objs.ValueStore{
		VSPreImage: &objs.VSPreImage{
			ChainID:  chainID,
			Value:    value2,
			Owner:    &objs.ValueStoreOwner{SVA: objs.ValueStoreSVA, CurveSpec: constants.CurveSecp256k1, Account: crypto.GetAccount(receiverPubkey)},
			TXOutIdx: 1,
		},
		TxHash: make([]byte, 32),
	}
	newUTXOSender := &objs.TXOut{}
	err = newUTXOSender.NewValueStore(newValueStoreSender)
	if err != nil {
		t.Fatal(err)
	}
	txOutPreHash, err := newUTXOSender.PreHash()
	if err != nil {
		t.Fatal(err)
	}
	log.Printf("TXOut PreHash: %x\n", txOutPreHash)
	newUTXOReceiver := &objs.TXOut{}
	err = newUTXOReceiver.NewValueStore(newValueStoreReceiver)
	if err != nil {
		t.Fatal(err)
	}
	tx.Vout = append(tx.Vout, newUTXOSender, newUTXOReceiver)
	err = tx.SetTxHash() // <- compute the root from the TxHash smt
	if err != nil {
		t.Fatal(err)
	}
	return tx
}

func GenerateBlock(chain []*cobjs.BClaims, stateRoot []byte, txHshLst [][]byte) ([]*cobjs.BClaims, error) {
	var prevBlock []byte
	var headerRoot []byte
	if len(chain) == 0 {
		chain = []*cobjs.BClaims{}
		prevBlock = crypto.Hasher([]byte("foo"))
		headerRoot = crypto.Hasher([]byte(""))
	} else {
		_prevBlock, err := chain[len(chain)-1].BlockHash()
		if err != nil {
			return nil, err
		}
		prevBlock = _prevBlock
		headerRoot = crypto.Hasher([]byte("")) // todo: how to generate the block smt
	}
	txRoot, err := cobjs.MakeTxRoot(txHshLst) // generating the smt root
	log.Printf("txRoot height: (%d): %x\n", len(chain)+1, txRoot)
	if err != nil {
		if err != nil {
			return nil, err
		}
	}
	bclaims := &cobjs.BClaims{
		ChainID:    1,
		Height:     uint32(len(chain) + 1),
		TxCount:    uint32(len(txHshLst)),
		PrevBlock:  prevBlock,
		TxRoot:     txRoot,
		StateRoot:  stateRoot,
		HeaderRoot: headerRoot,
	}
	chain = append(chain, bclaims)

	log.Printf(
		"\nBlock: {\n\tChainID: %d\n\tHeight: %d\n\tTxCount: %d\n\tPrevBlock: %x\n\tTxRoot: %x\n\tStateRoot: %x\n\tHeaderRoot: %x\n}\n\n",
		bclaims.ChainID,
		bclaims.Height,
		bclaims.TxCount,
		bclaims.PrevBlock,
		bclaims.TxRoot,
		bclaims.StateRoot,
		bclaims.HeaderRoot,
	)
	return chain, nil
}

func testMerkleProofDeserialization(mpbytes []byte, mproof *db.MerkleProof) error {
	mp1 := &db.MerkleProof{}
	err := mp1.UnmarshalBinary(mpbytes)
	if err != nil {
		return err
	}
	if mp1.Included != mproof.Included {
		errors.New(fmt.Sprintf("bad height: %t Expected: %t", mp1.Included, mproof.Included))
	}
	if mp1.KeyHeight != mproof.KeyHeight {
		errors.New(fmt.Sprintf("bad height: %d Expected: %d", mp1.KeyHeight, mproof.KeyHeight))
	}
	if !bytes.Equal(mp1.Key, mproof.Key) {
		errors.New(fmt.Sprintf("bad Key: %x Expected %x", mp1.Key, mproof.Key))
	}
	if !bytes.Equal(mp1.ProofKey, mproof.ProofKey) {
		errors.New(fmt.Sprintf("bad ProofKey: %x Expected: %x", mp1.ProofKey, mproof.ProofKey))
	}
	if !bytes.Equal(mp1.ProofValue, mproof.ProofValue) {
		errors.New(fmt.Sprintf("bad Next: %x Expected: %x", mp1.ProofValue, mproof.ProofValue))
	}
	if !bytes.Equal(mp1.Bitmap, mproof.Bitmap) {
		errors.New(fmt.Sprintf("bad Bitmap: %x Expected: %x", mp1.Bitmap, mproof.Bitmap))
	}
	for i := 0; i < len(mproof.Path); i++ {
		if !bytes.Equal(mp1.Path[i], mproof.Path[i]) {
			errors.New(fmt.Sprintf("bad Path: %s Expected: %x", mp1.Path[i], mproof.Path[i]))
		}
	}
	return nil
}

func getAllStateMerkleProofs(hndlr *UTXOHandler, txs []*objs.Tx) func(txn *badger.Txn) error {
	fn := func(txn *badger.Txn) error {
		stateTrie, err := hndlr.GetTrie().GetCurrentTrie(txn)
		if err != nil {
			return err
		}
		log.Printf("Trie height: %d\n", stateTrie.TrieHeight)
		for _, tx := range txs {
			txHash, err := tx.TxHash()
			if err != nil {
				return err
			}
			log.Println("===========Proof of inclusion=========")
			log.Printf("Tx: %x\n", txHash)
			log.Println("======================================")
			utxoIDs, err := tx.GeneratedUTXOID()
			if err != nil {
				return err
			}
			for i, utxoID := range utxoIDs {
				//auditPath, included, proofKey, proofVal, err := stateTrie.MerkleProof(txn, utxoID) // *badger.Txn, key []byte
				bitmap, auditPath, proofHeight, included, proofKey, proofVal, err := stateTrie.MerkleProofCompressed(txn, utxoID)
				if err != nil {
					return err
				}
				mproof := &db.MerkleProof{
					Included:   included,
					KeyHeight:  proofHeight,
					Key:        utxoID,
					ProofKey:   proofKey,
					ProofValue: proofVal,
					Bitmap:     bitmap,
					Path:       auditPath,
				}
				mpbytes, err := mproof.MarshalBinary()
				if err != nil {
					return err
				}
				err = testMerkleProofDeserialization(mpbytes, mproof)
				if err != nil {
					return err
				}
				log.Printf("UTXOID: %x\n", utxoID)
				log.Printf("auditPath: %x\n", auditPath)
				log.Printf("Bitmap: %x\n", bitmap)
				log.Printf("Proof height: %x\n", proofHeight)
				log.Print("Included:", included)
				log.Printf("Proof key: %x\n", proofKey)
				log.Printf("Proof value: %x\n", proofVal)
				log.Printf("Proof capnproto: %x\n", mpbytes)
				if len(utxoIDs) > i+1 {
					log.Println("---------------------")
				}
			}
			log.Println("======================================")
			log.Println()

		}
		return nil
	}
	return fn
}

func getStateMerkleProofs(hndlr *UTXOHandler, txs []*objs.Tx, utxoID []byte) func(txn *badger.Txn) error {
	fn := func(txn *badger.Txn) error {
		stateTrie, err := hndlr.GetTrie().GetCurrentTrie(txn)
		if err != nil {
			return err
		}
		log.Println("===========Proof of inclusion Separate Key =========")
		log.Printf("Trie height: %d\n", stateTrie.TrieHeight)
		bitmap, auditPath, proofHeight, included, proofKey, proofVal, err := stateTrie.MerkleProofCompressed(txn, utxoID)
		if err != nil {
			return err
		}
		result := stateTrie.VerifyInclusionC(bitmap, utxoID, proofVal, auditPath, proofHeight)
		log.Print("Is the proof compacted included in the trie: ", result)
		fakeProofKey, err := hex.DecodeString("80ab269d23d84721a53f9f3accb024a1947bcf5e4910a152f38d55d7d644c996")
		if err != nil {
			return err
		}
		resultNonIncluded := stateTrie.VerifyNonInclusionC(auditPath, proofHeight, bitmap, utxoID, proofVal, fakeProofKey)
		log.Print("Verify non inclusion the proof non compacted included in the trie: ", resultNonIncluded)

		fakeProofKey, err = hex.DecodeString("7a6315f5d19bf3f3bed9ef4e6002ebf76d4d05a7f7e84547e20b40fde2c34411")
		if err != nil {
			return err
		}
		fakeProofValue, err := hex.DecodeString("e10fbdbaa5b72d510af6dd5ebd08da8b2fbd2b06d4787ce15a6eaf518c2d97fc")
		if err != nil {
			return err
		}
		fakeProofHeight := 2
		resultNonIncluded = stateTrie.VerifyNonInclusionC(auditPath, fakeProofHeight, bitmap, utxoID, fakeProofValue, fakeProofKey)
		log.Print("Verify non inclusion the proof non compacted included in the trie 2: ", resultNonIncluded)

		auditPathNC, _, _, proofValNC, err := stateTrie.MerkleProof(txn, utxoID)
		if err != nil {
			return err
		}
		resultNC := stateTrie.VerifyInclusion(auditPathNC, utxoID, proofValNC)
		log.Print("Is the proof non compacted included in the trie: ", resultNC)
		log.Printf("auditPathNonCompacted: %x\n", auditPathNC)

		mproof := &db.MerkleProof{
			Included:   included,
			KeyHeight:  proofHeight,
			Key:        utxoID,
			ProofKey:   proofKey,
			ProofValue: proofVal,
			Bitmap:     bitmap,
			Path:       auditPath,
		}
		mpbytes, err := mproof.MarshalBinary()
		if err != nil {
			return err
		}
		err = testMerkleProofDeserialization(mpbytes, mproof)
		if err != nil {
			return err
		}
		log.Printf("UTXOID (Key): %x\n", utxoID)
		keyHash := []byte{}
		if mproof.ProofValue != nil {
			if mproof.ProofKey == nil {
				keyHash = crypto.Hasher(mproof.Key, mproof.ProofValue, []byte{byte(stateTrie.TrieHeight - mproof.KeyHeight)})
			} else {
				keyHash = crypto.Hasher(mproof.ProofKey, mproof.ProofValue, []byte{byte(stateTrie.TrieHeight - mproof.KeyHeight)})
			}
		}
		log.Printf("KeyHash: %x\n", keyHash)
		log.Printf("Bitmap: %x\n", bitmap)
		log.Printf("auditPathCompacted: %x\n", auditPath)
		log.Printf("Proof height: %x\n", proofHeight)
		log.Print("Included:", included)
		log.Printf("Proof key: %x\n", proofKey)
		log.Printf("Proof value: %x\n", proofVal)
		log.Printf("Proof capnproto: %x\n", mpbytes)
		log.Println("======================================")
		log.Println()
		return nil
	}
	return fn
}

func CreateMerkleProof(included bool, proofHeight int, key []byte, proofKey []byte, proofVal []byte, bitmap []byte, auditPath [][]byte) (*db.MerkleProof, error) {
	mproof := &db.MerkleProof{
		Included:   included,
		KeyHeight:  proofHeight,
		Key:        key,
		ProofKey:   proofKey,
		ProofValue: proofVal,
		Bitmap:     bitmap,
		Path:       auditPath,
	}
	mpbytes, err := mproof.MarshalBinary()
	if err != nil {
		return nil, err
	}
	err = testMerkleProofDeserialization(mpbytes, mproof)
	if err != nil {
		return nil, err
	}
	log.Println("===========Proof of inclusion =========")
	log.Printf("Bitmap: %x\n", mproof.Bitmap)
	log.Printf("auditPathCompacted: %x\n", mproof.Path)
	log.Printf("Proof height: %x\n", mproof.KeyHeight)
	log.Print("Included:", mproof.Included)
	log.Printf("Proof key: %x\n", mproof.ProofKey)
	log.Printf("Proof value: %x\n", mproof.ProofValue)
	log.Printf("Proof capnproto: %x\n", mpbytes)
	log.Println("======================================")
	log.Println()

	return mproof, nil
}

func TestRicLeo(t *testing.T) {
	// Database setup
	log.Println("TestRicLeo starting")
	dir, err := ioutil.TempDir("", "badger-test")
	if err != nil {
		t.Fatal(err)
	}
	defer func() {
		if err := os.RemoveAll(dir); err != nil {
			t.Fatal(err)
		}
	}()
	opts := badger.DefaultOptions(dir)
	db, err := badger.Open(opts)
	if err != nil {
		t.Fatal(err)
	}
	defer db.Close()

	//////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////
	signer := &crypto.Secp256k1Signer{}
	err = signer.SetPrivk(crypto.Hasher([]byte("secret")))

	if err != nil {
		t.Fatal(err)
	}

	signer2 := &crypto.Secp256k1Signer{}
	err = signer2.SetPrivk(crypto.Hasher([]byte("secret2")))

	if err != nil {
		t.Fatal(err)
	}

	hndlr := NewUTXOHandler(db)
	err = hndlr.Init(1)
	if err != nil {
		t.Fatal(err)
	}

	///////// Block 1 ////////////
	log.Println("Block 1:")
	// Creating First UTXO
	var txs []*objs.Tx
	var deposits []*objs.ValueStore
	var txHshLst [][]byte
	var txHshSMTs []*trie.SMT
	for i := uint64(0); i < 5; i++ {
		newTxn := db.NewTransaction(true)
		value := &uint256.Uint256{}
		tmp, ok := new(big.Int).SetString("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16)
		if !ok {
			t.Fatal(err)
		}
		_, _ = value.FromBigInt(tmp)
		deposits = append(deposits, makeDeposit(t, signer, 1, int(i), value)) // created pre-image object
		txs = append(txs, makeTxs(t, signer, deposits[i]))
		txHash, err := txs[i].TxHash()
		if err != nil {
			t.Fatal(err)
		}
		smtTxHsh, _, err := PersistentTxHash(newTxn, txs[i])
		if err != nil {
			t.Fatal(err)
		}
		log.Printf("Tx hash (%d): %x", i, txHash)
		txHshLst = append(txHshLst, txHash)
		txHshSMTs = append(txHshSMTs, smtTxHsh)
	}

	txBin, err := txs[0].Vin[0].TXInLinker.MarshalBinary()
	if err != nil {
		t.Fatal(err)
	}
	pubKey, err := signer.Pubkey()
	if err != nil {
		t.Fatal(err)
	}
	log.Printf("Owner address: %x", crypto.GetAccount(pubKey))
	if err != nil {
		t.Fatal(err)
	}
	log.Printf("TxIn binary: %x\n", txBin)
	newTxn := db.NewTransaction(true)
	//txHshSMTs[0].MerkleProofCompressed(newTxn, )

	var stateRoot []byte
	err = db.Update(func(txn *badger.Txn) error {
		stateRoot, err = hndlr.ApplyState(txn, txs, 1)
		if err != nil {
			t.Fatal(err)
		}
		log.Printf("stateRoot: %x\n", stateRoot)
		return nil
	})
	if err != nil {
		t.Fatal(err)
	}

	err = db.Update(getAllStateMerkleProofs(hndlr, txs))
	if err != nil {
		t.Fatal(err)
	}

	//80ab269d23d84721a53f9f3accb024a1947bcf5e4910a152f38d55d7d644c995 -> 10000000
	//9c2ab35f2eb16e010c0aaf3abae9f2eacd39fd564c9a151e790439f5666a9c2c
	//10110000 -> 10110000
	//Key: 80ab269d23d84721a53f9f3accb024a1947bcf5e4910a152f38d55d7d644c995 -> 0101 -> 8-> 1000
	// Proof Value: 0391f56ce9575815216c9c0fcffa1d50767adb008c1491b7da2dbc323b8c1fb5
	// Height: 252 -> FC
	// hash  80ab269d23d84721a53f9f3accb024a1947bcf5e4910a152f38d55d7d644c9950391f56ce9575815216c9c0fcffa1d50767adb008c1491b7da2dbc323b8c1fb5fc = a53ec428ed37200bcb4944a99107b738c1a58ef76287b130583095c58b0f45e4
	// HashProof: 066c7a6ef776fbae26f10eabcc5f0eb72b0f527c4cad8c4037940a28c2fe3159 bc36789e7a1e281436464229828f817d6612f7b477d66591ff96a9e064bcc98a 6974f1d60877fdff3125a5c1adb630afe3aa899820a0531cea8ee6a85eb11509 25fc463686d6201f9c3973a9ebeabe4375d5a76d935bbec6cbb9d18bffe67216
	// root 51f16d008cec2409af8104a0bca9facec585e02c12d2fa5221707672410dc692
	utxoID, err := hex.DecodeString("80ab269d23d84721a53f9f3accb024a1947bcf5e4910a152f38d55d7d644c996")
	if err != nil {
		t.Fatal(err)
	}
	err = db.Update(getStateMerkleProofs(hndlr, txs, utxoID))
	if err != nil {
		t.Fatal(err)
	}

	// Generating block 1
	chain, err := GenerateBlock(nil, stateRoot, txHshLst)
	if err != nil {
		t.Fatal(err)
	}

	newTxn = db.NewTransaction(true)
	smtTxRoot, txRoot, err := MakePersistentTxRoot(newTxn, txHshLst) // generating the smt root
	log.Printf("The transaction Root persisted: %x\n", txRoot)
	if err != nil {
		t.Fatal(err)
	}
	transactionIncluded, err := hex.DecodeString("77338383edde4a7477f32549672ce24ff2800d7b61bf71cac09fab6e9b008495")
	if err != nil {
		t.Fatal(err)
	}
	bitmap, auditPath, proofHeight, included, proofKey, proofVal, err := smtTxRoot.MerkleProofCompressed(newTxn, transactionIncluded)
	if err != nil {
		t.Fatal(err)
	}
	_, err = CreateMerkleProof(
		included,
		proofHeight,
		transactionIncluded,
		proofKey,
		proofVal,
		bitmap,
		auditPath,
	)
	if err != nil {
		t.Fatal(err)
	}

	////////// Block 2 /////////////
	// this is consuming utxo generated on block 1
	log.Println("Block 2:")
	tx2 := makeTransfer(t, signer, signer2, 1, txs[1].Vout[0]) //right way
	// value := &uint256.Uint256{}
	// _, _ = value.FromUint64(100000000 + 1)
	// UTXOCreatedFromThinAir := makeDeposit(t, signer, 1, int(200), value)
	// tx2 := makeTxs(t, signer, UTXOCreatedFromThinAir) //wrong way
	txHash2, err := tx2.TxHash()
	if err != nil {
		t.Fatal(err)
	}
	_, _, err = PersistentTxHash(newTxn, tx2)
	if err != nil {
		t.Fatal(err)
	}
	log.Printf("Tx hash: %x", txHash2)
	err = db.Update(func(txn *badger.Txn) error {
		stateRoot, err = hndlr.ApplyState(txn, []*objs.Tx{tx2}, 2)
		if err != nil {
			t.Fatal(err)
		}
		log.Printf("stateRoot2: %x\n", stateRoot)
		return nil
	})
	if err != nil {
		t.Fatal(err)
	}
	err = db.Update(getAllStateMerkleProofs(hndlr, []*objs.Tx{tx2}))
	if err != nil {
		t.Fatal(err)
	}

	chain, err = GenerateBlock(chain, stateRoot, [][]byte{txHash2})
	if err != nil {
		t.Fatal(err)
	}

	_, txRoot2, err := MakePersistentTxRoot(db.NewTransaction(true), [][]byte{txHash2}) // generating the smt root
	log.Printf("The transaction Root persisted Block 2: %x\n", txRoot2)
	if err != nil {
		t.Fatal(err)
	}

	//////////// Generating cobjs.BClaims and PClaims ////////////////////
	bnVal := &crypto.BNGroupValidator{}
	if err != nil {
		t.Fatal(err)
	}
	bclaims := chain[0]
	bhsh, err := bclaims.BlockHash()
	if err != nil {
		t.Fatal(err)
	}
	gk := &crypto.BNGroupSigner{}
	gk.SetPrivk(crypto.Hasher([]byte("secret")))
	sig, err := gk.Sign(bhsh)
	if err != nil {
		t.Fatal(err)
	}
	bh := &cobjs.BlockHeader{
		BClaims:  bclaims,
		SigGroup: sig,
		TxHshLst: txHshLst,
	}
	err = bh.ValidateSignatures(bnVal)
	if err != nil {
		t.Fatal(err)
	}
	rcert, err := bh.GetRCert()
	if err != nil {
		t.Fatal(err)
	}
	err = rcert.ValidateSignature(bnVal)
	if err != nil {
		t.Fatal(err)
	}
	bclaimsBin, err := chain[0].MarshalBinary()
	log.Printf("BClaim block 1: %x", bclaimsBin)
	log.Printf("SigGrup Block 1: %x", rcert.SigGroup)

	pclms := &cobjs.PClaims{
		BClaims: chain[1],
		RCert:   rcert,
	}

	pClaimsBin, err := pclms.MarshalBinary()
	log.Printf("PClaims Block 2: %x", pClaimsBin)
	prop := &cobjs.Proposal{
		PClaims:  pclms,
		TxHshLst: [][]byte{txHash2},
	}
	err = prop.Sign(signer)
	if err != nil {
		t.Fatal(err)
	}
	log.Printf("Sig PClaims Block 2: %x", prop.Signature)
}
