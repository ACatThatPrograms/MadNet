// Code generated by capnpc-go. DO NOT EDIT.

package capn

import (
	strconv "strconv"
	capnp "zombiezen.com/go/capnproto2"
	text "zombiezen.com/go/capnproto2/encoding/text"
	schemas "zombiezen.com/go/capnproto2/schemas"
)

// Constants defined in application.capnp.
var (
	DefaultDSPreImage   = DSPreImage{Struct: capnp.MustUnmarshalRootPtr(x_b99093b7d2518300[0:112]).Struct()}
	DefaultDSLinker     = DSLinker{Struct: capnp.MustUnmarshalRootPtr(x_b99093b7d2518300[112:248]).Struct()}
	DefaultVSPreImage   = VSPreImage{Struct: capnp.MustUnmarshalRootPtr(x_b99093b7d2518300[248:320]).Struct()}
	DefaultASPreImage   = ASPreImage{Struct: capnp.MustUnmarshalRootPtr(x_b99093b7d2518300[320:400]).Struct()}
	DefaultTXInPreImage = TXInPreImage{Struct: capnp.MustUnmarshalRootPtr(x_b99093b7d2518300[400:440]).Struct()}
	DefaultTXInLinker   = TXInLinker{Struct: capnp.MustUnmarshalRootPtr(x_b99093b7d2518300[440:504]).Struct()}
)

func init() {
	// Set traversal limit for constants as Uint64Max since they're safe from amplification attacks.
	DefaultDSPreImage.Segment().Message().ReadLimiter().Reset((1 << 64) - 1)
	DefaultDSLinker.Segment().Message().ReadLimiter().Reset((1 << 64) - 1)
	DefaultVSPreImage.Segment().Message().ReadLimiter().Reset((1 << 64) - 1)
	DefaultASPreImage.Segment().Message().ReadLimiter().Reset((1 << 64) - 1)
	DefaultTXInPreImage.Segment().Message().ReadLimiter().Reset((1 << 64) - 1)
	DefaultTXInLinker.Segment().Message().ReadLimiter().Reset((1 << 64) - 1)
}

type DSPreImage struct{ capnp.Struct }

// DSPreImage_TypeID is the unique identifier for the type DSPreImage.
const DSPreImage_TypeID = 0xd4eb3c212b8dbb26

func NewDSPreImage(s *capnp.Segment) (DSPreImage, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 48, PointerCount: 3})
	return DSPreImage{st}, err
}

func NewRootDSPreImage(s *capnp.Segment) (DSPreImage, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 48, PointerCount: 3})
	return DSPreImage{st}, err
}

func ReadRootDSPreImage(msg *capnp.Message) (DSPreImage, error) {
	root, err := msg.RootPtr()
	return DSPreImage{root.Struct()}, err
}

func (s DSPreImage) String() string {
	str, _ := text.Marshal(0xd4eb3c212b8dbb26, s.Struct)
	return str
}

func (s DSPreImage) ChainID() uint32 {
	return s.Struct.Uint32(0)
}

func (s DSPreImage) SetChainID(v uint32) {
	s.Struct.SetUint32(0, v)
}

func (s DSPreImage) Index() []byte {
	p, _ := s.Struct.Ptr(0)
	return []byte(p.DataDefault([]byte{0x0}))
}

func (s DSPreImage) HasIndex() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s DSPreImage) SetIndex(v []byte) error {
	if v == nil {
		v = []byte{}
	}
	return s.Struct.SetData(0, v)
}
func (s DSPreImage) IssuedAt() uint32 {
	return s.Struct.Uint32(4)
}

func (s DSPreImage) SetIssuedAt(v uint32) {
	s.Struct.SetUint32(4, v)
}

func (s DSPreImage) RawData() []byte {
	p, _ := s.Struct.Ptr(1)
	return []byte(p.DataDefault([]byte{0x0}))
}

func (s DSPreImage) HasRawData() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s DSPreImage) SetRawData(v []byte) error {
	if v == nil {
		v = []byte{}
	}
	return s.Struct.SetData(1, v)
}
func (s DSPreImage) TXOutIdx() uint32 {
	return s.Struct.Uint32(12)
}

func (s DSPreImage) SetTXOutIdx(v uint32) {
	s.Struct.SetUint32(12, v)
}

func (s DSPreImage) Owner() []byte {
	p, _ := s.Struct.Ptr(2)
	return []byte(p.DataDefault([]byte{0x0}))
}

func (s DSPreImage) HasOwner() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s DSPreImage) SetOwner(v []byte) error {
	if v == nil {
		v = []byte{}
	}
	return s.Struct.SetData(2, v)
}
func (s DSPreImage) Deposit() uint32 {
	return s.Struct.Uint32(8)
}

func (s DSPreImage) SetDeposit(v uint32) {
	s.Struct.SetUint32(8, v)
}

func (s DSPreImage) Deposit1() uint32 {
	return s.Struct.Uint32(16)
}

func (s DSPreImage) SetDeposit1(v uint32) {
	s.Struct.SetUint32(16, v)
}

func (s DSPreImage) Deposit2() uint32 {
	return s.Struct.Uint32(20)
}

func (s DSPreImage) SetDeposit2(v uint32) {
	s.Struct.SetUint32(20, v)
}

func (s DSPreImage) Deposit3() uint32 {
	return s.Struct.Uint32(24)
}

func (s DSPreImage) SetDeposit3(v uint32) {
	s.Struct.SetUint32(24, v)
}

func (s DSPreImage) Deposit4() uint32 {
	return s.Struct.Uint32(28)
}

func (s DSPreImage) SetDeposit4(v uint32) {
	s.Struct.SetUint32(28, v)
}

func (s DSPreImage) Deposit5() uint32 {
	return s.Struct.Uint32(32)
}

func (s DSPreImage) SetDeposit5(v uint32) {
	s.Struct.SetUint32(32, v)
}

func (s DSPreImage) Deposit6() uint32 {
	return s.Struct.Uint32(36)
}

func (s DSPreImage) SetDeposit6(v uint32) {
	s.Struct.SetUint32(36, v)
}

func (s DSPreImage) Deposit7() uint32 {
	return s.Struct.Uint32(40)
}

func (s DSPreImage) SetDeposit7(v uint32) {
	s.Struct.SetUint32(40, v)
}

// DSPreImage_List is a list of DSPreImage.
type DSPreImage_List struct{ capnp.List }

// NewDSPreImage creates a new list of DSPreImage.
func NewDSPreImage_List(s *capnp.Segment, sz int32) (DSPreImage_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 48, PointerCount: 3}, sz)
	return DSPreImage_List{l}, err
}

func (s DSPreImage_List) At(i int) DSPreImage { return DSPreImage{s.List.Struct(i)} }

func (s DSPreImage_List) Set(i int, v DSPreImage) error { return s.List.SetStruct(i, v.Struct) }

func (s DSPreImage_List) String() string {
	str, _ := text.MarshalList(0xd4eb3c212b8dbb26, s.List)
	return str
}

// DSPreImage_Promise is a wrapper for a DSPreImage promised by a client call.
type DSPreImage_Promise struct{ *capnp.Pipeline }

func (p DSPreImage_Promise) Struct() (DSPreImage, error) {
	s, err := p.Pipeline.Struct()
	return DSPreImage{s}, err
}

type DSLinker struct{ capnp.Struct }

// DSLinker_TypeID is the unique identifier for the type DSLinker.
const DSLinker_TypeID = 0x91989c51606be6c8

func NewDSLinker(s *capnp.Segment) (DSLinker, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return DSLinker{st}, err
}

func NewRootDSLinker(s *capnp.Segment) (DSLinker, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return DSLinker{st}, err
}

func ReadRootDSLinker(msg *capnp.Message) (DSLinker, error) {
	root, err := msg.RootPtr()
	return DSLinker{root.Struct()}, err
}

func (s DSLinker) String() string {
	str, _ := text.Marshal(0x91989c51606be6c8, s.Struct)
	return str
}

func (s DSLinker) DSPreImage() DSPreImage {
	if !s.HasDSPreImage() {
		s.NewDSPreImage()
	}
	p, _ := s.Struct.Ptr(0)
	ss, _ := p.StructDefault(x_b99093b7d2518300[504:616])
	return DSPreImage{Struct: ss}
}

func (s DSLinker) HasDSPreImage() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s DSLinker) SetDSPreImage(v DSPreImage) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDSPreImage sets the dSPreImage field to a newly
// allocated DSPreImage struct, preferring placement in s's segment.
func (s DSLinker) NewDSPreImage() (DSPreImage, error) {
	ss, err := NewDSPreImage(s.Struct.Segment())
	if err != nil {
		return DSPreImage{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}
func (s DSLinker) TxHash() []byte {
	p, _ := s.Struct.Ptr(1)
	return []byte(p.DataDefault([]byte{0x0}))
}

func (s DSLinker) HasTxHash() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s DSLinker) SetTxHash(v []byte) error {
	if v == nil {
		v = []byte{}
	}
	return s.Struct.SetData(1, v)
}

// DSLinker_List is a list of DSLinker.
type DSLinker_List struct{ capnp.List }

// NewDSLinker creates a new list of DSLinker.
func NewDSLinker_List(s *capnp.Segment, sz int32) (DSLinker_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return DSLinker_List{l}, err
}

func (s DSLinker_List) At(i int) DSLinker { return DSLinker{s.List.Struct(i)} }

func (s DSLinker_List) Set(i int, v DSLinker) error { return s.List.SetStruct(i, v.Struct) }

func (s DSLinker_List) String() string {
	str, _ := text.MarshalList(0x91989c51606be6c8, s.List)
	return str
}

// DSLinker_Promise is a wrapper for a DSLinker promised by a client call.
type DSLinker_Promise struct{ *capnp.Pipeline }

func (p DSLinker_Promise) Struct() (DSLinker, error) {
	s, err := p.Pipeline.Struct()
	return DSLinker{s}, err
}

func (p DSLinker_Promise) DSPreImage() DSPreImage_Promise {
	return DSPreImage_Promise{Pipeline: p.Pipeline.GetPipelineDefault(0, x_b99093b7d2518300[616:728])}
}

type DataStore struct{ capnp.Struct }

// DataStore_TypeID is the unique identifier for the type DataStore.
const DataStore_TypeID = 0x9843dfb8f1386b20

func NewDataStore(s *capnp.Segment) (DataStore, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return DataStore{st}, err
}

func NewRootDataStore(s *capnp.Segment) (DataStore, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return DataStore{st}, err
}

func ReadRootDataStore(msg *capnp.Message) (DataStore, error) {
	root, err := msg.RootPtr()
	return DataStore{root.Struct()}, err
}

func (s DataStore) String() string {
	str, _ := text.Marshal(0x9843dfb8f1386b20, s.Struct)
	return str
}

func (s DataStore) DSLinker() DSLinker {
	if !s.HasDSLinker() {
		s.NewDSLinker()
	}
	p, _ := s.Struct.Ptr(0)
	ss, _ := p.StructDefault(x_b99093b7d2518300[728:864])
	return DSLinker{Struct: ss}
}

func (s DataStore) HasDSLinker() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s DataStore) SetDSLinker(v DSLinker) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDSLinker sets the dSLinker field to a newly
// allocated DSLinker struct, preferring placement in s's segment.
func (s DataStore) NewDSLinker() (DSLinker, error) {
	ss, err := NewDSLinker(s.Struct.Segment())
	if err != nil {
		return DSLinker{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}
func (s DataStore) Signature() []byte {
	p, _ := s.Struct.Ptr(1)
	return []byte(p.DataDefault([]byte{0x0}))
}

func (s DataStore) HasSignature() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s DataStore) SetSignature(v []byte) error {
	if v == nil {
		v = []byte{}
	}
	return s.Struct.SetData(1, v)
}

// DataStore_List is a list of DataStore.
type DataStore_List struct{ capnp.List }

// NewDataStore creates a new list of DataStore.
func NewDataStore_List(s *capnp.Segment, sz int32) (DataStore_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return DataStore_List{l}, err
}

func (s DataStore_List) At(i int) DataStore { return DataStore{s.List.Struct(i)} }

func (s DataStore_List) Set(i int, v DataStore) error { return s.List.SetStruct(i, v.Struct) }

func (s DataStore_List) String() string {
	str, _ := text.MarshalList(0x9843dfb8f1386b20, s.List)
	return str
}

// DataStore_Promise is a wrapper for a DataStore promised by a client call.
type DataStore_Promise struct{ *capnp.Pipeline }

func (p DataStore_Promise) Struct() (DataStore, error) {
	s, err := p.Pipeline.Struct()
	return DataStore{s}, err
}

func (p DataStore_Promise) DSLinker() DSLinker_Promise {
	return DSLinker_Promise{Pipeline: p.Pipeline.GetPipelineDefault(0, x_b99093b7d2518300[864:1000])}
}

type VSPreImage struct{ capnp.Struct }

// VSPreImage_TypeID is the unique identifier for the type VSPreImage.
const VSPreImage_TypeID = 0xf8c203f305398e1b

func NewVSPreImage(s *capnp.Segment) (VSPreImage, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1})
	return VSPreImage{st}, err
}

func NewRootVSPreImage(s *capnp.Segment) (VSPreImage, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1})
	return VSPreImage{st}, err
}

func ReadRootVSPreImage(msg *capnp.Message) (VSPreImage, error) {
	root, err := msg.RootPtr()
	return VSPreImage{root.Struct()}, err
}

func (s VSPreImage) String() string {
	str, _ := text.Marshal(0xf8c203f305398e1b, s.Struct)
	return str
}

func (s VSPreImage) ChainID() uint32 {
	return s.Struct.Uint32(0)
}

func (s VSPreImage) SetChainID(v uint32) {
	s.Struct.SetUint32(0, v)
}

func (s VSPreImage) TXOutIdx() uint32 {
	return s.Struct.Uint32(8)
}

func (s VSPreImage) SetTXOutIdx(v uint32) {
	s.Struct.SetUint32(8, v)
}

func (s VSPreImage) Owner() []byte {
	p, _ := s.Struct.Ptr(0)
	return []byte(p.DataDefault([]byte{0x0}))
}

func (s VSPreImage) HasOwner() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s VSPreImage) SetOwner(v []byte) error {
	if v == nil {
		v = []byte{}
	}
	return s.Struct.SetData(0, v)
}
func (s VSPreImage) Value() uint32 {
	return s.Struct.Uint32(4)
}

func (s VSPreImage) SetValue(v uint32) {
	s.Struct.SetUint32(4, v)
}

func (s VSPreImage) Value1() uint32 {
	return s.Struct.Uint32(12)
}

func (s VSPreImage) SetValue1(v uint32) {
	s.Struct.SetUint32(12, v)
}

func (s VSPreImage) Value2() uint32 {
	return s.Struct.Uint32(16)
}

func (s VSPreImage) SetValue2(v uint32) {
	s.Struct.SetUint32(16, v)
}

func (s VSPreImage) Value3() uint32 {
	return s.Struct.Uint32(20)
}

func (s VSPreImage) SetValue3(v uint32) {
	s.Struct.SetUint32(20, v)
}

func (s VSPreImage) Value4() uint32 {
	return s.Struct.Uint32(24)
}

func (s VSPreImage) SetValue4(v uint32) {
	s.Struct.SetUint32(24, v)
}

func (s VSPreImage) Value5() uint32 {
	return s.Struct.Uint32(28)
}

func (s VSPreImage) SetValue5(v uint32) {
	s.Struct.SetUint32(28, v)
}

func (s VSPreImage) Value6() uint32 {
	return s.Struct.Uint32(32)
}

func (s VSPreImage) SetValue6(v uint32) {
	s.Struct.SetUint32(32, v)
}

func (s VSPreImage) Value7() uint32 {
	return s.Struct.Uint32(36)
}

func (s VSPreImage) SetValue7(v uint32) {
	s.Struct.SetUint32(36, v)
}

// VSPreImage_List is a list of VSPreImage.
type VSPreImage_List struct{ capnp.List }

// NewVSPreImage creates a new list of VSPreImage.
func NewVSPreImage_List(s *capnp.Segment, sz int32) (VSPreImage_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1}, sz)
	return VSPreImage_List{l}, err
}

func (s VSPreImage_List) At(i int) VSPreImage { return VSPreImage{s.List.Struct(i)} }

func (s VSPreImage_List) Set(i int, v VSPreImage) error { return s.List.SetStruct(i, v.Struct) }

func (s VSPreImage_List) String() string {
	str, _ := text.MarshalList(0xf8c203f305398e1b, s.List)
	return str
}

// VSPreImage_Promise is a wrapper for a VSPreImage promised by a client call.
type VSPreImage_Promise struct{ *capnp.Pipeline }

func (p VSPreImage_Promise) Struct() (VSPreImage, error) {
	s, err := p.Pipeline.Struct()
	return VSPreImage{s}, err
}

type ValueStore struct{ capnp.Struct }

// ValueStore_TypeID is the unique identifier for the type ValueStore.
const ValueStore_TypeID = 0xa031328fb2fcc743

func NewValueStore(s *capnp.Segment) (ValueStore, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return ValueStore{st}, err
}

func NewRootValueStore(s *capnp.Segment) (ValueStore, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return ValueStore{st}, err
}

func ReadRootValueStore(msg *capnp.Message) (ValueStore, error) {
	root, err := msg.RootPtr()
	return ValueStore{root.Struct()}, err
}

func (s ValueStore) String() string {
	str, _ := text.Marshal(0xa031328fb2fcc743, s.Struct)
	return str
}

func (s ValueStore) VSPreImage() VSPreImage {
	if !s.HasVSPreImage() {
		s.NewVSPreImage()
	}
	p, _ := s.Struct.Ptr(0)
	ss, _ := p.StructDefault(x_b99093b7d2518300[1000:1072])
	return VSPreImage{Struct: ss}
}

func (s ValueStore) HasVSPreImage() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ValueStore) SetVSPreImage(v VSPreImage) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewVSPreImage sets the vSPreImage field to a newly
// allocated VSPreImage struct, preferring placement in s's segment.
func (s ValueStore) NewVSPreImage() (VSPreImage, error) {
	ss, err := NewVSPreImage(s.Struct.Segment())
	if err != nil {
		return VSPreImage{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}
func (s ValueStore) TxHash() []byte {
	p, _ := s.Struct.Ptr(1)
	return []byte(p.DataDefault([]byte{0x0}))
}

func (s ValueStore) HasTxHash() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s ValueStore) SetTxHash(v []byte) error {
	if v == nil {
		v = []byte{}
	}
	return s.Struct.SetData(1, v)
}

// ValueStore_List is a list of ValueStore.
type ValueStore_List struct{ capnp.List }

// NewValueStore creates a new list of ValueStore.
func NewValueStore_List(s *capnp.Segment, sz int32) (ValueStore_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return ValueStore_List{l}, err
}

func (s ValueStore_List) At(i int) ValueStore { return ValueStore{s.List.Struct(i)} }

func (s ValueStore_List) Set(i int, v ValueStore) error { return s.List.SetStruct(i, v.Struct) }

func (s ValueStore_List) String() string {
	str, _ := text.MarshalList(0xa031328fb2fcc743, s.List)
	return str
}

// ValueStore_Promise is a wrapper for a ValueStore promised by a client call.
type ValueStore_Promise struct{ *capnp.Pipeline }

func (p ValueStore_Promise) Struct() (ValueStore, error) {
	s, err := p.Pipeline.Struct()
	return ValueStore{s}, err
}

func (p ValueStore_Promise) VSPreImage() VSPreImage_Promise {
	return VSPreImage_Promise{Pipeline: p.Pipeline.GetPipelineDefault(0, x_b99093b7d2518300[1072:1144])}
}

type ASPreImage struct{ capnp.Struct }

// ASPreImage_TypeID is the unique identifier for the type ASPreImage.
const ASPreImage_TypeID = 0xa6bc62ab6b339789

func NewASPreImage(s *capnp.Segment) (ASPreImage, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 48, PointerCount: 1})
	return ASPreImage{st}, err
}

func NewRootASPreImage(s *capnp.Segment) (ASPreImage, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 48, PointerCount: 1})
	return ASPreImage{st}, err
}

func ReadRootASPreImage(msg *capnp.Message) (ASPreImage, error) {
	root, err := msg.RootPtr()
	return ASPreImage{root.Struct()}, err
}

func (s ASPreImage) String() string {
	str, _ := text.Marshal(0xa6bc62ab6b339789, s.Struct)
	return str
}

func (s ASPreImage) ChainID() uint32 {
	return s.Struct.Uint32(0)
}

func (s ASPreImage) SetChainID(v uint32) {
	s.Struct.SetUint32(0, v)
}

func (s ASPreImage) TXOutIdx() uint32 {
	return s.Struct.Uint32(8)
}

func (s ASPreImage) SetTXOutIdx(v uint32) {
	s.Struct.SetUint32(8, v)
}

func (s ASPreImage) Owner() []byte {
	p, _ := s.Struct.Ptr(0)
	return []byte(p.DataDefault([]byte{0x0}))
}

func (s ASPreImage) HasOwner() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ASPreImage) SetOwner(v []byte) error {
	if v == nil {
		v = []byte{}
	}
	return s.Struct.SetData(0, v)
}
func (s ASPreImage) IssuedAt() uint32 {
	return s.Struct.Uint32(12)
}

func (s ASPreImage) SetIssuedAt(v uint32) {
	s.Struct.SetUint32(12, v)
}

func (s ASPreImage) Exp() uint32 {
	return s.Struct.Uint32(16)
}

func (s ASPreImage) SetExp(v uint32) {
	s.Struct.SetUint32(16, v)
}

func (s ASPreImage) Value() uint32 {
	return s.Struct.Uint32(4)
}

func (s ASPreImage) SetValue(v uint32) {
	s.Struct.SetUint32(4, v)
}

func (s ASPreImage) Value1() uint32 {
	return s.Struct.Uint32(20)
}

func (s ASPreImage) SetValue1(v uint32) {
	s.Struct.SetUint32(20, v)
}

func (s ASPreImage) Value2() uint32 {
	return s.Struct.Uint32(24)
}

func (s ASPreImage) SetValue2(v uint32) {
	s.Struct.SetUint32(24, v)
}

func (s ASPreImage) Value3() uint32 {
	return s.Struct.Uint32(28)
}

func (s ASPreImage) SetValue3(v uint32) {
	s.Struct.SetUint32(28, v)
}

func (s ASPreImage) Value4() uint32 {
	return s.Struct.Uint32(32)
}

func (s ASPreImage) SetValue4(v uint32) {
	s.Struct.SetUint32(32, v)
}

func (s ASPreImage) Value5() uint32 {
	return s.Struct.Uint32(36)
}

func (s ASPreImage) SetValue5(v uint32) {
	s.Struct.SetUint32(36, v)
}

func (s ASPreImage) Value6() uint32 {
	return s.Struct.Uint32(40)
}

func (s ASPreImage) SetValue6(v uint32) {
	s.Struct.SetUint32(40, v)
}

func (s ASPreImage) Value7() uint32 {
	return s.Struct.Uint32(44)
}

func (s ASPreImage) SetValue7(v uint32) {
	s.Struct.SetUint32(44, v)
}

// ASPreImage_List is a list of ASPreImage.
type ASPreImage_List struct{ capnp.List }

// NewASPreImage creates a new list of ASPreImage.
func NewASPreImage_List(s *capnp.Segment, sz int32) (ASPreImage_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 48, PointerCount: 1}, sz)
	return ASPreImage_List{l}, err
}

func (s ASPreImage_List) At(i int) ASPreImage { return ASPreImage{s.List.Struct(i)} }

func (s ASPreImage_List) Set(i int, v ASPreImage) error { return s.List.SetStruct(i, v.Struct) }

func (s ASPreImage_List) String() string {
	str, _ := text.MarshalList(0xa6bc62ab6b339789, s.List)
	return str
}

// ASPreImage_Promise is a wrapper for a ASPreImage promised by a client call.
type ASPreImage_Promise struct{ *capnp.Pipeline }

func (p ASPreImage_Promise) Struct() (ASPreImage, error) {
	s, err := p.Pipeline.Struct()
	return ASPreImage{s}, err
}

type AtomicSwap struct{ capnp.Struct }

// AtomicSwap_TypeID is the unique identifier for the type AtomicSwap.
const AtomicSwap_TypeID = 0xc9c165c236a1bd53

func NewAtomicSwap(s *capnp.Segment) (AtomicSwap, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return AtomicSwap{st}, err
}

func NewRootAtomicSwap(s *capnp.Segment) (AtomicSwap, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return AtomicSwap{st}, err
}

func ReadRootAtomicSwap(msg *capnp.Message) (AtomicSwap, error) {
	root, err := msg.RootPtr()
	return AtomicSwap{root.Struct()}, err
}

func (s AtomicSwap) String() string {
	str, _ := text.Marshal(0xc9c165c236a1bd53, s.Struct)
	return str
}

func (s AtomicSwap) ASPreImage() ASPreImage {
	if !s.HasASPreImage() {
		s.NewASPreImage()
	}
	p, _ := s.Struct.Ptr(0)
	ss, _ := p.StructDefault(x_b99093b7d2518300[1144:1224])
	return ASPreImage{Struct: ss}
}

func (s AtomicSwap) HasASPreImage() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s AtomicSwap) SetASPreImage(v ASPreImage) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewASPreImage sets the aSPreImage field to a newly
// allocated ASPreImage struct, preferring placement in s's segment.
func (s AtomicSwap) NewASPreImage() (ASPreImage, error) {
	ss, err := NewASPreImage(s.Struct.Segment())
	if err != nil {
		return ASPreImage{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}
func (s AtomicSwap) TxHash() []byte {
	p, _ := s.Struct.Ptr(1)
	return []byte(p.DataDefault([]byte{0x0}))
}

func (s AtomicSwap) HasTxHash() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s AtomicSwap) SetTxHash(v []byte) error {
	if v == nil {
		v = []byte{}
	}
	return s.Struct.SetData(1, v)
}

// AtomicSwap_List is a list of AtomicSwap.
type AtomicSwap_List struct{ capnp.List }

// NewAtomicSwap creates a new list of AtomicSwap.
func NewAtomicSwap_List(s *capnp.Segment, sz int32) (AtomicSwap_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return AtomicSwap_List{l}, err
}

func (s AtomicSwap_List) At(i int) AtomicSwap { return AtomicSwap{s.List.Struct(i)} }

func (s AtomicSwap_List) Set(i int, v AtomicSwap) error { return s.List.SetStruct(i, v.Struct) }

func (s AtomicSwap_List) String() string {
	str, _ := text.MarshalList(0xc9c165c236a1bd53, s.List)
	return str
}

// AtomicSwap_Promise is a wrapper for a AtomicSwap promised by a client call.
type AtomicSwap_Promise struct{ *capnp.Pipeline }

func (p AtomicSwap_Promise) Struct() (AtomicSwap, error) {
	s, err := p.Pipeline.Struct()
	return AtomicSwap{s}, err
}

func (p AtomicSwap_Promise) ASPreImage() ASPreImage_Promise {
	return ASPreImage_Promise{Pipeline: p.Pipeline.GetPipelineDefault(0, x_b99093b7d2518300[1224:1304])}
}

type TXInPreImage struct{ capnp.Struct }

// TXInPreImage_TypeID is the unique identifier for the type TXInPreImage.
const TXInPreImage_TypeID = 0xbb0225ef96e5ba9f

func NewTXInPreImage(s *capnp.Segment) (TXInPreImage, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return TXInPreImage{st}, err
}

func NewRootTXInPreImage(s *capnp.Segment) (TXInPreImage, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return TXInPreImage{st}, err
}

func ReadRootTXInPreImage(msg *capnp.Message) (TXInPreImage, error) {
	root, err := msg.RootPtr()
	return TXInPreImage{root.Struct()}, err
}

func (s TXInPreImage) String() string {
	str, _ := text.Marshal(0xbb0225ef96e5ba9f, s.Struct)
	return str
}

func (s TXInPreImage) ChainID() uint32 {
	return s.Struct.Uint32(0)
}

func (s TXInPreImage) SetChainID(v uint32) {
	s.Struct.SetUint32(0, v)
}

func (s TXInPreImage) ConsumedTxIdx() uint32 {
	return s.Struct.Uint32(4)
}

func (s TXInPreImage) SetConsumedTxIdx(v uint32) {
	s.Struct.SetUint32(4, v)
}

func (s TXInPreImage) ConsumedTxHash() []byte {
	p, _ := s.Struct.Ptr(0)
	return []byte(p.DataDefault([]byte{0x0}))
}

func (s TXInPreImage) HasConsumedTxHash() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TXInPreImage) SetConsumedTxHash(v []byte) error {
	if v == nil {
		v = []byte{}
	}
	return s.Struct.SetData(0, v)
}

// TXInPreImage_List is a list of TXInPreImage.
type TXInPreImage_List struct{ capnp.List }

// NewTXInPreImage creates a new list of TXInPreImage.
func NewTXInPreImage_List(s *capnp.Segment, sz int32) (TXInPreImage_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return TXInPreImage_List{l}, err
}

func (s TXInPreImage_List) At(i int) TXInPreImage { return TXInPreImage{s.List.Struct(i)} }

func (s TXInPreImage_List) Set(i int, v TXInPreImage) error { return s.List.SetStruct(i, v.Struct) }

func (s TXInPreImage_List) String() string {
	str, _ := text.MarshalList(0xbb0225ef96e5ba9f, s.List)
	return str
}

// TXInPreImage_Promise is a wrapper for a TXInPreImage promised by a client call.
type TXInPreImage_Promise struct{ *capnp.Pipeline }

func (p TXInPreImage_Promise) Struct() (TXInPreImage, error) {
	s, err := p.Pipeline.Struct()
	return TXInPreImage{s}, err
}

type TXInLinker struct{ capnp.Struct }

// TXInLinker_TypeID is the unique identifier for the type TXInLinker.
const TXInLinker_TypeID = 0x958c34c871381d2c

func NewTXInLinker(s *capnp.Segment) (TXInLinker, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return TXInLinker{st}, err
}

func NewRootTXInLinker(s *capnp.Segment) (TXInLinker, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return TXInLinker{st}, err
}

func ReadRootTXInLinker(msg *capnp.Message) (TXInLinker, error) {
	root, err := msg.RootPtr()
	return TXInLinker{root.Struct()}, err
}

func (s TXInLinker) String() string {
	str, _ := text.Marshal(0x958c34c871381d2c, s.Struct)
	return str
}

func (s TXInLinker) TXInPreImage() TXInPreImage {
	if !s.HasTXInPreImage() {
		s.NewTXInPreImage()
	}
	p, _ := s.Struct.Ptr(0)
	ss, _ := p.StructDefault(x_b99093b7d2518300[1304:1344])
	return TXInPreImage{Struct: ss}
}

func (s TXInLinker) HasTXInPreImage() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TXInLinker) SetTXInPreImage(v TXInPreImage) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTXInPreImage sets the tXInPreImage field to a newly
// allocated TXInPreImage struct, preferring placement in s's segment.
func (s TXInLinker) NewTXInPreImage() (TXInPreImage, error) {
	ss, err := NewTXInPreImage(s.Struct.Segment())
	if err != nil {
		return TXInPreImage{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}
func (s TXInLinker) TxHash() []byte {
	p, _ := s.Struct.Ptr(1)
	return []byte(p.DataDefault([]byte{0x0}))
}

func (s TXInLinker) HasTxHash() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s TXInLinker) SetTxHash(v []byte) error {
	if v == nil {
		v = []byte{}
	}
	return s.Struct.SetData(1, v)
}

// TXInLinker_List is a list of TXInLinker.
type TXInLinker_List struct{ capnp.List }

// NewTXInLinker creates a new list of TXInLinker.
func NewTXInLinker_List(s *capnp.Segment, sz int32) (TXInLinker_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return TXInLinker_List{l}, err
}

func (s TXInLinker_List) At(i int) TXInLinker { return TXInLinker{s.List.Struct(i)} }

func (s TXInLinker_List) Set(i int, v TXInLinker) error { return s.List.SetStruct(i, v.Struct) }

func (s TXInLinker_List) String() string {
	str, _ := text.MarshalList(0x958c34c871381d2c, s.List)
	return str
}

// TXInLinker_Promise is a wrapper for a TXInLinker promised by a client call.
type TXInLinker_Promise struct{ *capnp.Pipeline }

func (p TXInLinker_Promise) Struct() (TXInLinker, error) {
	s, err := p.Pipeline.Struct()
	return TXInLinker{s}, err
}

func (p TXInLinker_Promise) TXInPreImage() TXInPreImage_Promise {
	return TXInPreImage_Promise{Pipeline: p.Pipeline.GetPipelineDefault(0, x_b99093b7d2518300[1344:1384])}
}

type TXIn struct{ capnp.Struct }

// TXIn_TypeID is the unique identifier for the type TXIn.
const TXIn_TypeID = 0xb105e7dd5c44b39c

func NewTXIn(s *capnp.Segment) (TXIn, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return TXIn{st}, err
}

func NewRootTXIn(s *capnp.Segment) (TXIn, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return TXIn{st}, err
}

func ReadRootTXIn(msg *capnp.Message) (TXIn, error) {
	root, err := msg.RootPtr()
	return TXIn{root.Struct()}, err
}

func (s TXIn) String() string {
	str, _ := text.Marshal(0xb105e7dd5c44b39c, s.Struct)
	return str
}

func (s TXIn) TXInLinker() TXInLinker {
	if !s.HasTXInLinker() {
		s.NewTXInLinker()
	}
	p, _ := s.Struct.Ptr(0)
	ss, _ := p.StructDefault(x_b99093b7d2518300[1384:1448])
	return TXInLinker{Struct: ss}
}

func (s TXIn) HasTXInLinker() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TXIn) SetTXInLinker(v TXInLinker) error {
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewTXInLinker sets the tXInLinker field to a newly
// allocated TXInLinker struct, preferring placement in s's segment.
func (s TXIn) NewTXInLinker() (TXInLinker, error) {
	ss, err := NewTXInLinker(s.Struct.Segment())
	if err != nil {
		return TXInLinker{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}
func (s TXIn) Signature() []byte {
	p, _ := s.Struct.Ptr(1)
	return []byte(p.DataDefault([]byte{0x0}))
}

func (s TXIn) HasSignature() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s TXIn) SetSignature(v []byte) error {
	if v == nil {
		v = []byte{}
	}
	return s.Struct.SetData(1, v)
}

// TXIn_List is a list of TXIn.
type TXIn_List struct{ capnp.List }

// NewTXIn creates a new list of TXIn.
func NewTXIn_List(s *capnp.Segment, sz int32) (TXIn_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return TXIn_List{l}, err
}

func (s TXIn_List) At(i int) TXIn { return TXIn{s.List.Struct(i)} }

func (s TXIn_List) Set(i int, v TXIn) error { return s.List.SetStruct(i, v.Struct) }

func (s TXIn_List) String() string {
	str, _ := text.MarshalList(0xb105e7dd5c44b39c, s.List)
	return str
}

// TXIn_Promise is a wrapper for a TXIn promised by a client call.
type TXIn_Promise struct{ *capnp.Pipeline }

func (p TXIn_Promise) Struct() (TXIn, error) {
	s, err := p.Pipeline.Struct()
	return TXIn{s}, err
}

func (p TXIn_Promise) TXInLinker() TXInLinker_Promise {
	return TXInLinker_Promise{Pipeline: p.Pipeline.GetPipelineDefault(0, x_b99093b7d2518300[1448:1512])}
}

type TXOut struct{ capnp.Struct }
type TXOut_Which uint16

const (
	TXOut_Which_dataStore  TXOut_Which = 0
	TXOut_Which_valueStore TXOut_Which = 1
	TXOut_Which_atomicSwap TXOut_Which = 2
)

func (w TXOut_Which) String() string {
	const s = "dataStorevalueStoreatomicSwap"
	switch w {
	case TXOut_Which_dataStore:
		return s[0:9]
	case TXOut_Which_valueStore:
		return s[9:19]
	case TXOut_Which_atomicSwap:
		return s[19:29]

	}
	return "TXOut_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// TXOut_TypeID is the unique identifier for the type TXOut.
const TXOut_TypeID = 0xfb4425cca53d7224

func NewTXOut(s *capnp.Segment) (TXOut, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return TXOut{st}, err
}

func NewRootTXOut(s *capnp.Segment) (TXOut, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return TXOut{st}, err
}

func ReadRootTXOut(msg *capnp.Message) (TXOut, error) {
	root, err := msg.RootPtr()
	return TXOut{root.Struct()}, err
}

func (s TXOut) String() string {
	str, _ := text.Marshal(0xfb4425cca53d7224, s.Struct)
	return str
}

func (s TXOut) Which() TXOut_Which {
	return TXOut_Which(s.Struct.Uint16(0))
}
func (s TXOut) DataStore() (DataStore, error) {
	if s.Struct.Uint16(0) != 0 {
		panic("Which() != dataStore")
	}
	p, err := s.Struct.Ptr(0)
	if err != nil {
		return DataStore{}, err
	}
	return DataStore{Struct: p.Struct()}, err
}

func (s TXOut) HasDataStore() bool {
	if s.Struct.Uint16(0) != 0 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TXOut) SetDataStore(v DataStore) error {
	s.Struct.SetUint16(0, 0)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewDataStore sets the dataStore field to a newly
// allocated DataStore struct, preferring placement in s's segment.
func (s TXOut) NewDataStore() (DataStore, error) {
	s.Struct.SetUint16(0, 0)
	ss, err := NewDataStore(s.Struct.Segment())
	if err != nil {
		return DataStore{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}
func (s TXOut) ValueStore() (ValueStore, error) {
	if s.Struct.Uint16(0) != 1 {
		panic("Which() != valueStore")
	}
	p, err := s.Struct.Ptr(0)
	if err != nil {
		return ValueStore{}, err
	}
	return ValueStore{Struct: p.Struct()}, err
}

func (s TXOut) HasValueStore() bool {
	if s.Struct.Uint16(0) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TXOut) SetValueStore(v ValueStore) error {
	s.Struct.SetUint16(0, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewValueStore sets the valueStore field to a newly
// allocated ValueStore struct, preferring placement in s's segment.
func (s TXOut) NewValueStore() (ValueStore, error) {
	s.Struct.SetUint16(0, 1)
	ss, err := NewValueStore(s.Struct.Segment())
	if err != nil {
		return ValueStore{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}
func (s TXOut) AtomicSwap() (AtomicSwap, error) {
	if s.Struct.Uint16(0) != 2 {
		panic("Which() != atomicSwap")
	}
	p, err := s.Struct.Ptr(0)
	if err != nil {
		return AtomicSwap{}, err
	}
	return AtomicSwap{Struct: p.Struct()}, err
}

func (s TXOut) HasAtomicSwap() bool {
	if s.Struct.Uint16(0) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s TXOut) SetAtomicSwap(v AtomicSwap) error {
	s.Struct.SetUint16(0, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAtomicSwap sets the atomicSwap field to a newly
// allocated AtomicSwap struct, preferring placement in s's segment.
func (s TXOut) NewAtomicSwap() (AtomicSwap, error) {
	s.Struct.SetUint16(0, 2)
	ss, err := NewAtomicSwap(s.Struct.Segment())
	if err != nil {
		return AtomicSwap{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// TXOut_List is a list of TXOut.
type TXOut_List struct{ capnp.List }

// NewTXOut creates a new list of TXOut.
func NewTXOut_List(s *capnp.Segment, sz int32) (TXOut_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return TXOut_List{l}, err
}

func (s TXOut_List) At(i int) TXOut { return TXOut{s.List.Struct(i)} }

func (s TXOut_List) Set(i int, v TXOut) error { return s.List.SetStruct(i, v.Struct) }

func (s TXOut_List) String() string {
	str, _ := text.MarshalList(0xfb4425cca53d7224, s.List)
	return str
}

// TXOut_Promise is a wrapper for a TXOut promised by a client call.
type TXOut_Promise struct{ *capnp.Pipeline }

func (p TXOut_Promise) Struct() (TXOut, error) {
	s, err := p.Pipeline.Struct()
	return TXOut{s}, err
}

func (p TXOut_Promise) DataStore() DataStore_Promise {
	return DataStore_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TXOut_Promise) ValueStore() ValueStore_Promise {
	return ValueStore_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p TXOut_Promise) AtomicSwap() AtomicSwap_Promise {
	return AtomicSwap_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type Tx struct{ capnp.Struct }

// Tx_TypeID is the unique identifier for the type Tx.
const Tx_TypeID = 0x97ffa3012c4f6a3e

func NewTx(s *capnp.Segment) (Tx, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Tx{st}, err
}

func NewRootTx(s *capnp.Segment) (Tx, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Tx{st}, err
}

func ReadRootTx(msg *capnp.Message) (Tx, error) {
	root, err := msg.RootPtr()
	return Tx{root.Struct()}, err
}

func (s Tx) String() string {
	str, _ := text.Marshal(0x97ffa3012c4f6a3e, s.Struct)
	return str
}

func (s Tx) Vin() (TXIn_List, error) {
	p, err := s.Struct.Ptr(0)
	if err != nil {
		return TXIn_List{}, err
	}
	l, err := p.ListDefault(x_b99093b7d2518300[1512:1536])
	return TXIn_List{List: l}, err
}

func (s Tx) HasVin() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s Tx) SetVin(v TXIn_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewVin sets the vin field to a newly
// allocated TXIn_List, preferring placement in s's segment.
func (s Tx) NewVin(n int32) (TXIn_List, error) {
	l, err := NewTXIn_List(s.Struct.Segment(), n)
	if err != nil {
		return TXIn_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

func (s Tx) Vout() (TXOut_List, error) {
	p, err := s.Struct.Ptr(1)
	if err != nil {
		return TXOut_List{}, err
	}
	l, err := p.ListDefault(x_b99093b7d2518300[1536:1560])
	return TXOut_List{List: l}, err
}

func (s Tx) HasVout() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s Tx) SetVout(v TXOut_List) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewVout sets the vout field to a newly
// allocated TXOut_List, preferring placement in s's segment.
func (s Tx) NewVout(n int32) (TXOut_List, error) {
	l, err := NewTXOut_List(s.Struct.Segment(), n)
	if err != nil {
		return TXOut_List{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

// Tx_List is a list of Tx.
type Tx_List struct{ capnp.List }

// NewTx creates a new list of Tx.
func NewTx_List(s *capnp.Segment, sz int32) (Tx_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return Tx_List{l}, err
}

func (s Tx_List) At(i int) Tx { return Tx{s.List.Struct(i)} }

func (s Tx_List) Set(i int, v Tx) error { return s.List.SetStruct(i, v.Struct) }

func (s Tx_List) String() string {
	str, _ := text.MarshalList(0x97ffa3012c4f6a3e, s.List)
	return str
}

// Tx_Promise is a wrapper for a Tx promised by a client call.
type Tx_Promise struct{ *capnp.Pipeline }

func (p Tx_Promise) Struct() (Tx, error) {
	s, err := p.Pipeline.Struct()
	return Tx{s}, err
}

const schema_b99093b7d2518300 = "x\xda\xbc\x97kl\x1cW\x15\xc7\xcf\x99;3\xeb]" +
	"?w\xef\x0a\x90\x10Jk%\x08\x17\x83\xe2Wb\"" +
	"\x1b\xdb\xedZ\xf2V\x8e\xb2\xd3\xd9\x16S\xb9R\x07\xef" +
	"\x10o\x9d}\xb0\x9e\x8d7\x88\xaaAi\xa4VrB" +
	"\xa2\xa6\xd4\x91\xd2\x92\xa8\xb4J\xa9x\x04Z\xd1\xb4A" +
	"\xa2\x11\x05W*R\x83ZAQK\x05\x82\xa2\x1a!" +
	"@|A@3\xe8\x9c\xd9\xd7\xec\xaec#!\xa4\xfd" +
	"\xb0\xf7\xb7g\xef\xfd\xdfs\xcf\xfd\x9f\x99\xdds\xda\xa4" +
	"2\xa0\xed\xd5\x01\x8c\x19MwK\x91\xdf<\xd9\xb77" +
	"\x7f\x12\xc2\x11\xf5\xfa1\xe3\x17?|\xe4\xd4e\xc0!" +
	"\x14\xbd(\xc3\"\x00`v\x08\x81\xe6G\x84\x82\x00\xee" +
	"\xfa{K\xf7\x1a\xe7\xd6NC8\x82\x95hM\x09\x00" +
	"\xc8>\xf1k9B\xf1r@\xac\x00\xba\xfd\x1f\x1b\xfd" +
	"\xd2\xfa\xf0\xea\xa3\xcd\x91\xaf\x88\x0dy\x8d#\x7f\xce\x91" +
	"\x9f\xbd\xef@?>\xe9>\xd6\x1c9\xae~KN\xab" +
	"\xf4mJ\xa5\xc8\xd5\xb1\xf7\x1e\x1f~\xe4Ck\x0dZ" +
	"_Q{Q\xbeIq\xe6\xeb\xaa@\xf3m\x95\xb5\xde" +
	"\xb44\xfa\xb7\x17\xde\xbdm\xady\xde\x0f\xd4\xdf\xc9\xa0" +
	"F\xdf4\x8d\xe6\xbd\xedg\xff\xfe\xfe\xd7\x06\x07\xce7" +
	"G>\xa3m\xc8\xe79\xf2\x12G\xde\x92\xba\xfe\xec\xe4" +
	"\xe7\x8e\x9doP0\xa0GPN\xe9\xa4`L\x17h" +
	"\xce\xe8\xac\xe0\xcc\xf4\xf8/\x8f\xfdu\xf8\xe9\x86\xe8\xa2" +
	"\xde\x8b\xf28G\x1f\xa5\xe8U/\xfa\xe1\xc7\x86\x96\x9e" +
	"\xfd\xc2\x95\xa7\xc1\x88\xa0^\x95\x81\xb4\xf8Y}C>" +
	"E\x7f\x18\xba\xa0\xbf\xab\x00\xba\xef\xf7\xedy\xe2\xa7'" +
	"\x8f|\xa7a\xe6\xc7\x83\x83(\xbf\x1d\xa4\x99/\x06\x05" +
	"\x9a\xcf\x05y\xe6s?\x88\xcd\xbf\xf3G\xedR\xf3\xfe" +
	".\x05_\x94\x97)^>\x1f\xa4\xfd}\xe3\xc5?|" +
	"\xfd/\xbb\x94\x97H\x03\xfa5\x8c\x84\xfe)\xa7B|" +
	",\xa1\xef\x02\xba\xe6\x8f.\xec\xb9j\xbf\xfcj\xf3\xa4" +
	"\xbf\x0dm\xc8?s\xe4\xfb!\x9a\xf4\xe3/\x9d\xf8\xe4" +
	"\xcdc\x7fz\xc3\xbf1\xae\x80L\xfb\x86<\xd2N\x1b" +
	"+\xb6\x7fX\x00\xba\x1f=\xf9\x19\xed\xef\xe2\xea?(" +
	"V\xf3\x0b\xb8\xd6\xb5!\xdf\xe9\xa2\xd8\xb7\xbar\x94\x84" +
	"\x9d\x85\xf1\xa7^\xdb\x15\xfb\x97O\xec4\x06\x04\x80\xfc" +
	"|\xf8\xaa\xb4\xc2\xf4\xb7{\xc2\xa4\xf6\xe67\xaf\x9c\xda" +
	"\xbf\xfe\x84\xdbX\xe6\x11*\xf3\x08\x97y\x84\xca<\xc2" +
	"\x09\xb3\xf2\xf9C\xe9\x05\xcb\x11\xe9\\\xf6\xd3\x0bV>" +
	"\x9b\xdf\x97\xb2\xbfh\x15\x0f9Sf\xa2`\xc73\x01" +
	"\xeb\xa0\x9d@\xc4\x9e\xda\xa9\x01b\x0f@BG\xd0\xc2" +
	"\x18\xaa\x9bD\xa9M\x123g\xd3\xd9%a\x17\x12\x88" +
	"F\x9bP\x01TD\x0c\xf7\xdd\x0d`|B\xa01\xac" +
	"`\x181\x8a\x04\xad}\x00\xc6\xbc@cQA7\xe5" +
	"-k\x818hcO-\xa3\x95E\x05h\xe1`\xc8" +
	"\xfb\x802\xe1\x94f\xac\xe5E\xec\x04\x05;\x016\x95" +
	"\x93\x9c\x8bgg\xd3\xdd\xd9\xa5&A\xf7\xb5\x104N" +
	"\x82F\x05\x1a1\x05]g.\x9e%I\xd0\x9d\xb1X" +
	"R\xb5r\xca\x92\x10\xcb\x0b\xdfP\x0cV\xc4t\xe7\xf7" +
	"%K\x0d\"z\x01\x8c\x9d\x02\x8d\xc9:\x11S\xb7\x00" +
	"\x18c\x02\x8d9\x05\x03\x87\xd3Y\xec\x02L\x08:\x88" +
	"j\x91\x03b\x17\xad\x13\x98T\xba\x0f\xe7\x8aN-\xa4" +
	"Z0\xd5\x90\x04\xe2\x0d\x0e;\xd6x\xd8[\xe4\xbd\xe5" +
	"\x91[\x8ee:\x81\\\xc1n\xd8\xdd\xed-R\x9c\xb9" +
	"\x03\xc08$\xd0(\xf1\x99S\xb1\xd8\x05\x00\xc0\x9e\x9a" +
	"\xf3zKO*\x86\xaa\x8b\xf0@\xa8^\x80p\x97\xd3" +
	"\x07\xb3\x96S,\x00\xda[\x9e\xfe]\xd6\xa1\xa2mv" +
	";\xcd\xd2Z\x95\xe3~:\xfd\x19\x81FRA\xf7\xb0" +
	"\xbf\x1c\xab\x97\xb6\x9c\x16\x0dA\xdd\xfa\xec[\xe5\x9bw" +
	"\x8c\x05/\xdb\xdb\xdb\xf2\xe6\xd3\xdd\xd5x|\x9b\xeal" +
	"\x95\x1e\xef\xa6sySz\x86+\xe9\x91\xf7\xe0\xad\x00" +
	"\xe6\x1c\x0a4S\xa8`X\xf32$-\x1c\x040\xe7" +
	"\x89/\x12G%\x8a\x0a\xa2\xb4\xf1v\x003E<O" +
	"@\x89\xa2@\x94\x19\x0e_$\xecP\xb8\x10QT\x11" +
	"e\x91\xc3\x1d\xe2G\x89\xabj\x145Dy?\xf6\x02" +
	"\x98%\xe2\x0f\x12\xd7\xb5(\xea\x88\xf2\xab\xb8\x0f\xc0\xfc" +
	"\x0a\xf1\x87\x88\x07\xf4(\x06\x10\xe5q\xe6G\x89\xaf\x12" +
	"o\x0bD\xb1\x0dQ>\xcc\xfcA\xe2\xa7\x88\x07\xdb\xa2" +
	"\x18D\x94'\x98?D\xfc\x0c\xf1P0\x8a!Dy" +
	"\x9a\xf9*\xf15\xe2\xed\xa1(\xb6#\xcaG\x99\x9f\"" +
	"~\x8exG{\x14;\x10\xe5Y\xe6g\x88\x9fG\x05" +
	"\x1fXX\xb4\xd2\xd9x\x0c\xdb@\xc16\xc0\x1d\x87\xa9" +
	"\xec*#\xd7\x99;Pt\xe2\xa9\x12\x15y%\"\xb7" +
	"\x92\xb5\x0b\xfe\x9aI//\x17\xed\xd4\x94S\x17\x16\xb0" +
	"K\xf9\xca\xf7\x09\x9et\xc0?\x1c\xf4\x0f\x87\xfc\xc3a" +
	"\xffp\xc4?\xdc\xe3\x1f\xee\xad\xea\xdd\xbc\xda\x92\x9e#" +
	"\xee\x88g\xaa\xf5\xb6\xa9'6\xfb\xdf\x84\xe7\xc6\xdb\xb8" +
	"\x88\xf1;\xea.\xa2\xc3\x0e\x9e]\x02a\x17\xb0\xa7\xf6" +
	"\xd0U\xbb1\x88\xe1\xce\x90\xb7,\xfeW\xf6\xe0\xedg" +
	"\xc2\xae\xec\xc7\xe8\xa8\xea\x9a\xbe\x15\xc0\x98\x14h\xcc\xd6" +
	"\xeb*\xd4t\x95K?l|\x19\xc0H\x084\xe6\x9b" +
	"\x0b\xc1]\xc8e\x97\x8b\x19;\x05;\x92\xa5x\xaa\xd4" +
	"\xcc'\x92\xdbkcSN.\x93^\xe86W\xac\xfc" +
	"6\xf2g\x90\x91\xcdz\x1d\xc4\xb5\xfcF\xb6i3\xdf" +
	"nG\x8d\xf9Mc\xb4j\x1aG\xd84\xaa\xb7\xba," +
	"F\xde\xcf&P\xbb\xd4\x0az\x9eq\x9cM\xa0vI" +
	"\xf5\xb2i\x9c\xe0ij\x97T\xa0g\x1a\xa7\x99\xd7." +
	"\xa9*<\xd38\xcb\xf3\xac\x11\xff&{\x95\xe2\x99\xc6" +
	"\x05^\xf7\x1c\xf1\x8bl\x1a\xaag\x1a\xcfp\xfcE\xe2" +
	"\xcf\xb1ih\x9ei\\b\xfe=\xe2W\xd84t\xcf" +
	"4.3\x7f\x81\xf8O\xd84\x02\x9ei\xbc\xcc\xfc\xc7" +
	"\xc4_c\xd3h\xf3L\xe3U\xe6\xeb\xc4\xdf`\xd3\x08" +
	"z\xa6q\x8d\xf9\xeb\xc4\xdf&\xde\x19\x8ab'\xa2|" +
	"\x8b\xf9\xaf\x88\xff\xbe\x95\x99\xa4\xb3)\xbb\xb4\xa5U<" +
	"\x90\xb2\xf3\xb9\xe5\xb4S\x1d\x17\xac\x15\xea\xcb\xfe?n" +
	"\xd3\x8a\xcas\x0d\xd4\x85U\xd8`\x0b6\xd4\x82\x0d\xb7" +
	"`#-\xd8\x9e\x16lo=k\xd5\xd5\xfd\x15\xd8_" +
	"\xad\xc0]\\\"7Q*\xfb+\xa5C\xbc\x8fKa" +
	"'\xf1\xdd\xf5m\xebS\x9c\xfa~\xe2\xa3umk\x84" +
	"\xc3w\x13\x1e\xabT\x1aU\xe08\xdb\xfe(\xf1\x18W" +
	"Z\xb9mM1\x1f#>S\xdf\xb6\xa6\x99O\x12\x9f" +
	"\xado[q\xe61\xe2\x89\xfa\xb6\xb5\x9f\xf9\x0c\xf1d" +
	"}\xdb2\x98\xcf\x12\x9f\xabo[w2O\x10\x9f\xff" +
	"_\xb5\xa1\xff\x7f\x9b\xf1\xf9\xf1\x81\xa2\x03e#\xeep" +
	"]\x95\x9a\xc945\x83\x98@#\xa1`'^w\xa3" +
	"\xdcb\xf6\xdf]\xb3\xb8N\xe5\x037\x8a\x0a@\xf8N" +
	"\xa2I\x81\xc6\xbd\xf4p\xc9\x8f\xa59\xee\x04=\xb5W" +
	"e\xf6=tY\x8d\xe9\xe4@\x14\xe8\xe7\xea\xfbq\xf9" +
	"g\x8b\x0d\xd7\\\x01a\xe5\xb1\xa7\xf6&X\xf9\xf9\x86" +
	"=r6\x9d\x0dx/\x1c[7\xac\xff\x04\x00\x00\xff" +
	"\xffD\x0b\xa4\xe4"

func init() {
	schemas.Register(schema_b99093b7d2518300,
		0x8e703729a3de1278,
		0x91989c51606be6c8,
		0x958c34c871381d2c,
		0x97ffa3012c4f6a3e,
		0x981693349de63c8c,
		0x9843dfb8f1386b20,
		0xa031328fb2fcc743,
		0xa0835740abfe642a,
		0xa634f083d73d4594,
		0xa6bc62ab6b339789,
		0xae798ec69e3629e9,
		0xb105e7dd5c44b39c,
		0xbb0225ef96e5ba9f,
		0xc9c165c236a1bd53,
		0xd4eb3c212b8dbb26,
		0xf8c203f305398e1b,
		0xfb4425cca53d7224,
		0xff9ec84d90bcd521)
}

var x_b99093b7d2518300 = []byte{
	0, 0, 0, 0, 13, 0, 0, 0,
	0, 0, 0, 0, 6, 0, 3, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	9, 0, 0, 0, 10, 0, 0, 0,
	9, 0, 0, 0, 10, 0, 0, 0,
	9, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 16, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 2, 0,
	4, 0, 0, 0, 6, 0, 3, 0,
	49, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	9, 0, 0, 0, 10, 0, 0, 0,
	9, 0, 0, 0, 10, 0, 0, 0,
	9, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 8, 0, 0, 0,
	0, 0, 0, 0, 5, 0, 1, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	1, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 9, 0, 0, 0,
	0, 0, 0, 0, 6, 0, 1, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	1, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 4, 0, 0, 0,
	0, 0, 0, 0, 1, 0, 1, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	1, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 7, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 2, 0,
	4, 0, 0, 0, 1, 0, 1, 0,
	13, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	1, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 13, 0, 0, 0,
	0, 0, 0, 0, 6, 0, 3, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	9, 0, 0, 0, 10, 0, 0, 0,
	9, 0, 0, 0, 10, 0, 0, 0,
	9, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 13, 0, 0, 0,
	0, 0, 0, 0, 6, 0, 3, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	9, 0, 0, 0, 10, 0, 0, 0,
	9, 0, 0, 0, 10, 0, 0, 0,
	9, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 16, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 2, 0,
	4, 0, 0, 0, 6, 0, 3, 0,
	49, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	9, 0, 0, 0, 10, 0, 0, 0,
	9, 0, 0, 0, 10, 0, 0, 0,
	9, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 16, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 2, 0,
	4, 0, 0, 0, 6, 0, 3, 0,
	49, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	9, 0, 0, 0, 10, 0, 0, 0,
	9, 0, 0, 0, 10, 0, 0, 0,
	9, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 8, 0, 0, 0,
	0, 0, 0, 0, 5, 0, 1, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	1, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 8, 0, 0, 0,
	0, 0, 0, 0, 5, 0, 1, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	1, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 9, 0, 0, 0,
	0, 0, 0, 0, 6, 0, 1, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	1, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 9, 0, 0, 0,
	0, 0, 0, 0, 6, 0, 1, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	1, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 4, 0, 0, 0,
	0, 0, 0, 0, 1, 0, 1, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	1, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 4, 0, 0, 0,
	0, 0, 0, 0, 1, 0, 1, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	1, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 7, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 2, 0,
	4, 0, 0, 0, 1, 0, 1, 0,
	13, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	1, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 7, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 2, 0,
	4, 0, 0, 0, 1, 0, 1, 0,
	13, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	1, 0, 0, 0, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 2, 0, 0, 0,
	1, 0, 0, 0, 7, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 2, 0,
	0, 0, 0, 0, 2, 0, 0, 0,
	1, 0, 0, 0, 7, 0, 0, 0,
	0, 0, 0, 0, 1, 0, 1, 0,
}
