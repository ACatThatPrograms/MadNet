package errorz

import (
	"errors"
	"fmt"
	"runtime"
	"strings"
)

const (
	maxErrDepth = 7
)

var _ ErrMadNet = (*errMadNet)(nil)

// ErrMadNet is the custom error type used for MadNet.
// This error class acts as a normal error from go<1.13
// and also creates the necessary logic for handling
// go>=1.13 error handling.
// Base Use Example:
//
//  func foo() (int, error) {
//    aInt, err := bar()
//    if err != nil {
//      return errorz.Wrap(err)
//    }
//  }
//
// Extra features:
// This error type allows a traces of up to depth
// seven to be generated by wrapping at each layer of
// the call stack.
// Example:
//
//  func foo() (int, error) {
//    aInt, err := bar()
//    if err != nil {
//      return errorz.Wrap(err).WithTrace()
//    }
//  }
//
//  _, err := foo()
//  fmt.Printf("%s", strings.Join(foo, "\n"))
//
//  Result:
//  /some/package/path/to/file.go:line#
//
//  Where line number will be equal to the line
//  `return errorz.Wrap(err).WithTrace()`
//
// This error class also allows a set of context variables
// to be attached to the error through WithContext()
// These context variable will print to the right of the traceback and
// after the error string for the root error.
type ErrMadNet interface {
	// Error interface method
	Error() string
	String() string
	// Unwrap for go>=1.13 unwrapping logic - IE: errors.Is and errors.As
	Unwrap() error
	// Trace returns a sorted list of called line numbers with context for
	// error tracing. Trace will only return data if WithTrace has been called
	// at some point in the stack. Otherwise it will return an empty list.
	Trace() []string
	// HasTrace returns true if any child error or the current error has a
	// trace enabled.
	HasTrace() bool
	// TraceStart returns the depth at which the trace begins in the error stack.
	// The max trace depth is 7. After seven trace entries have been added to the
	// trace stack, higher errors will simply proxy the trace of lower errors back
	// to the caller. The depth is measured as the number of times wrap is called
	// after the first time WithTrace() is called. This limit is to prevent
	// excessive abuse of CPU and memory for stack traces that may be discarded
	// by the caller.
	TraceStart() int
	// Depth returns the error stack depth.
	Depth() int
	// WithTrace enables tracing for the current error stack.
	WithTrace() ErrMadNet
	// WithContext allows a format string and a set of args to be passed for
	// string formatting. These values will be printed after the error message
	// for the bottom of the stack and beside the trace for elements above the
	// root of the stack.
	WithContext(fstring string, ctx ...interface{}) ErrMadNet
}

type errMadNet struct {
	err        error
	msg        string
	trace      string
	traceStart int
	depth      int
}

func (e *errMadNet) Depth() int {
	return e.depth
}

func (e *errMadNet) Error() string {
	return e.String()
}

func (e errMadNet) String() string {
	if e.HasTrace() {
		return strings.Join(e.Trace(), "\n")
	}
	return e.err.Error()
}

func (e *errMadNet) TraceStart() int {
	return e.traceStart
}

func (e *errMadNet) HasTrace() bool {
	return e.traceStart > 0
}

func (e *errMadNet) Unwrap() error {
	return e.err
}

func (e *errMadNet) Trace() []string {
	et, ok := e.err.(ErrMadNet)
	if ok {
		if maxErrDepth == e.depth-e.traceStart {
			return et.Trace()
		}
		if maxErrDepth > e.depth-e.traceStart {
			return append([]string{e.trace + fmt.Sprintf(" %s", e.msg)}, et.Trace()...)
		}
		if maxErrDepth < e.depth-e.traceStart {
			return et.Trace()
		}
	}
	return []string{fmt.Sprintf("%v %s", e.trace, e.msg)}
}

func (e *errMadNet) WithTrace() ErrMadNet {
	return e.withTrace()
}

func (e *errMadNet) withTrace() ErrMadNet {
	var stackDepth int
	switch {
	case e.traceStart == 0:
		stackDepth = 3
		e.traceStart = e.depth
	case e.depth < e.traceStart+maxErrDepth && e.trace == "":
		stackDepth = 3
	}
	if stackDepth > 0 {
		pc := make([]uintptr, stackDepth*2)
		n := runtime.Callers(stackDepth, pc)
		frames := runtime.CallersFrames(pc[:n])
		frame, _ := frames.Next()
		e.trace = fmt.Sprintf("%s:%d", frame.File, frame.Line)
	}
	return e
}

func (e *errMadNet) WithContext(fstring string, ctx ...interface{}) ErrMadNet {
	e.msg += fmt.Sprintf(fstring, ctx...)
	return e
}

// Wrap an existing error and return a MadNetError
func Wrap(e error) ErrMadNet {
	et := &errMadNet{}
	child, ok := e.(ErrMadNet)
	if ok {
		et.err = e
		et.depth = child.Depth() + 1
		if child.HasTrace() {
			et.traceStart = child.TraceStart()
			et.withTrace()
		}
		return et
	}
	et.err = e
	et.depth = 1
	et.msg = e.Error()
	return et
}

// New creates a new MadNetError from a string
func New(e string) ErrMadNet {
	err := &errMadNet{err: errors.New(e), msg: e, depth: 1}
	return err
}

// Newf creates a new MadNetError with string formatting
func Newf(fmtString string, args interface{}) ErrMadNet {
	msg := fmt.Sprintf(fmtString, args)
	err := &errMadNet{err: errors.New(msg), msg: msg, depth: 1}
	return err
}

// ErrMadNetType is a function for use in As
// IE As(<something>, ErrMadNetType())
func ErrMadNetType() **errMadNet {
	var e *errMadNet
	return &e
}

// As is shadowed export of errors.As
var As = errors.As

// Is is shadowed export of errors.Is
var Is = errors.Is
